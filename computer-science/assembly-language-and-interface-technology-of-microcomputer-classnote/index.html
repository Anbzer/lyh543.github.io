<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>汇编语言与微机接口技术 课程笔记 | 小灰灰灰灰的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="计算机科学,课程笔记,汇编语言">
    <meta name="description" content="授课老师：廖建明老师 教材：《微机原理与接口技术》(第4版). 吴宁,乔亚男主编. 清华大学出版社 参考教材:《汇编语言程序设计》. 廖建明主编.清华大学出版社  微型计算机基础概论计算机的工作原理计算机中的指令执行过程：取指令 -&amp;gt; 指令译码 -&amp;gt; 读取操作数 -&amp;gt; 执行命令 -&amp;gt; 存放结果">
<meta name="keywords" content="计算机科学,课程笔记,汇编语言">
<meta property="og:type" content="article">
<meta property="og:title" content="汇编语言与微机接口技术 课程笔记">
<meta property="og:url" content="https://blog.lyh543.cn/computer-science/assembly-language-and-interface-technology-of-microcomputer-classnote/index.html">
<meta property="og:site_name" content="小灰灰灰灰的博客">
<meta property="og:description" content="授课老师：廖建明老师 教材：《微机原理与接口技术》(第4版). 吴宁,乔亚男主编. 清华大学出版社 参考教材:《汇编语言程序设计》. 廖建明主编.清华大学出版社  微型计算机基础概论计算机的工作原理计算机中的指令执行过程：取指令 -&amp;gt; 指令译码 -&amp;gt; 读取操作数 -&amp;gt; 执行命令 -&amp;gt; 存放结果">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/2b125ce6885b6eddbe43b0c1b94ea20d5b0f18a475587854d4bda793f548e73f.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/7ad14e65b5c37de1842d043b016c76a8d3bd32ce0a7851e280bdc84c13ebcb99.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/155a118f5171dbabacdf915d12b68eaa987f1b740a9d36ddda8463d00aebb92e.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/6496134227c8788122f9189f659d55960174a1226f8bdb7595368e5b24ee7f3d.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/400c11160d21c24a4001d80071e2fef1906a764604fe8d687d74affc03defa92.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/98680035b5a29445842f7489e2f5bfc56cebba8a27c8b951523eca8fae9fcf61.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/cafe7330e111a3f1db574ccbf7a1fcd0f4a47c03fd9cb14a0f846ce6a3066737.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/a52f6b563d277084286fabdc71037dc19a5d732c34de36e070670376d34ef179.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/0b6da650308dced8aadba7cd9c0fed64fd1c1ec9ee3231a82918654770f4a920.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/468d81f9a1623be2e0ff52fa5f0910af4f05b6e3ec0bf0d92df5611edcdad93c.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/637600cc1fa7d7355b08efe783b6db99f560352a79bdad2cc637429962eeecfe.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/5f6126651c2f92a12a399a23042e32e90604a3789775ee239e68fd6f8b9ef288.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/64c036d835f462697d02fab06b3524811e1605b5cd80c872d5aef524a496b8e4.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/3232f210c17ae3c8dcf5384bf31e3a457ab22a7a88caa61a1c862f07d3c62488.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/77fefbfe1c701322f95e03a68a9212d17f7de87ad156678cc4add7ee1d9b6665.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/99150753542d61ed4eb265a6a2dd0cd31be1d9d30ddc3bbfbf4ed264a76d7563.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/64806a8d406e61c0d8767705627eb3d62880eb95146547c02b9069fa3f1e3081.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/b548bde2652a6b919ff10a3ca85fbe324b33efbaf64d64fe059b59982ee3c548.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/053fb371fb6454e749e0b163a18e8e20a4f10f5ceb7a3dd32f021e19c821f50f.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/48c324c8082d27de0d88346a4f03c24cb3b9da3e5e30b1b3f1a265a52aeb198c.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/185bcf860d26194ac5ff1dcc95bc396fdec6ee583de45f5150c77e8e38bfd9f5.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/97454c165ea943f277fbbf346f091226dd54d155a0678fdd453919ae592e4780.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/2fbb6ff64908cc7b0d609d1ba77d9a3353734cdcb4e49274614eceb091f15273.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/d857aaca3e3dff84edbd0a230fe994898971b8d736b5cf940ef3848e12988443.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/9b4089dedd698d5d3c336282839346d84df2928f47f32a7e9eec7da59bfed41d.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/a4d3d11ebac6286de0ea91217c9941d71fce115a37ebc3c65a91302fe8cda623.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/c298ac75a7755956f0b65e0222ade4838590cb5b0a50fbe9c0f103803996a4c7.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/313ab77109d17290d961fac8dab9a4dca36e1ab3282568bcecea8c4949e1b12f.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/9d6ae3513ebf9224b7268780a93e05b6b4a1d70762be0212b6e991f7934fc20a.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/f7908757260263ea785a2ea08addf225754d8b67ea31c51c5dd02b93306dce11.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/81aee00541b6ed26f57a285dfca95ed8bfc39ea105dbbbebf22a990d8eb52243.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/080823908581cf98753c95657c5977caa9527af6badf435488b8a85f259ebf59.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/cd909019497371be41e17abadc1a7d8a5d78f524873fe4445d3ecb2ddea1148d.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/4a158b764ea4be17e2ce448671ea8b29a4fcf7f42685e7e20c2466b98e9c7bab.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/81f301c50d50d3cab2d8782fbef2224215544487edc8c2f1a6b1ba875d45eef0.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/50517c34007f40bc1e32bd967274f7cae5a7056bc92b41a514d7ae2edecea51e.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/9495b586ce3ba38f7e4915566d352552ccdb4f13299c0f77c495008bc6e56b58.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/19dd0bb079591ffd2724c014246374d23fbad8fd1a3863a1d2d895ca61b35062.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/4cdfa19a2e508875f011987428fe17c8a5942632dc0454993f043e233e66c906.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/3e47c7ad9897cd201bca3cb98b632a54d0726fed5bf6e84033770d34eaeb9f3d.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/8fe69e6b5caee4cf1b7ed605fa1c7c1173a0d5ab42f9bf0526e616fa68d19ee9.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/d28ed269b600f75c3d3596cf6fd508f4d27b6668606c7e3ca96cbdec4290ecd3.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/ffe42aec65bbfba62190672930bf7d56bc382215b41cbbd5cd4b2e2d22ea5c62.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/b5c6d77b0f09db79bc86f1f25cb8cb26b0528094b205b42684cc7b04bbe67b2a.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/d9203225ce9f68a97b811f0b7a0036e74a9aa84c55827106925f29e9ffe02b03.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/6939376970e09f4138063eaf1684ec0cbc84518c32bc2a5ddd5887720210c590.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/f07b55addce64725145a23c41700eebda4947fd3721354d4acc6add68c3dd409.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/1adbd5c08e7d6d1bda5ecb588ec10f9b5336c76828a436559717805bc257daa2.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/5d244f81043fbffb79a752c98e4480efa41ab9585c8cd0e27c0e7f3fe3e7ca20.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/46007672f8e2139fa723af128b6b5f41941975311881900e46d6e8d2926b7d9f.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/71d57c3c15f9f63ab17f8b1613b7570bac1fd1a32e057d04e2d545424d0c86d1.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/5cc3b593d59435947e0ba5e9ffee706d873d9e7a0031d7f506015b64c36384cf.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/3ece5bd5b42862946c6175223499ee3b77fdc6cc7916ee57a572ceee0267d1bc.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/282107de057cb912c39b1e4280688ca798324e448b4123a35dec7d4355b2ddd1.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/75d5aab2e89484cb5e629d88f5b36a4574c3bd86224bbda12a5ec56bd0865b75.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/5370d71c8a40900e23d1a12d8c5c48f6229a59dfb1504056cce3b0e71c180fc0.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/20a5c3d0761cc76031f79f5614dfcd829e3fa595afa28c3ed9ec8e811e2b4855.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/740e07dc751a8a621249923fc873f59e1eed613e8ef78cde4a10a5c13ab81c66.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/b0511e29b7cdda8e6854a123995af5eb1ba0228928dc5157ff13bb2d0d100edd.png">
<meta property="og:updated_time" content="2020-10-27T16:11:05.482Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="汇编语言与微机接口技术 课程笔记">
<meta name="twitter:description" content="授课老师：廖建明老师 教材：《微机原理与接口技术》(第4版). 吴宁,乔亚男主编. 清华大学出版社 参考教材:《汇编语言程序设计》. 廖建明主编.清华大学出版社  微型计算机基础概论计算机的工作原理计算机中的指令执行过程：取指令 -&amp;gt; 指令译码 -&amp;gt; 读取操作数 -&amp;gt; 执行命令 -&amp;gt; 存放结果">
<meta name="twitter:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/2b125ce6885b6eddbe43b0c1b94ea20d5b0f18a475587854d4bda793f548e73f.png">
    
        <link rel="alternate" type="application/atom+xml" title="小灰灰灰灰的博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.png">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu"  >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">lyh543</h5>
          <a href="mailto:lyh543@outlook.com" title="lyh543@outlook.com" class="mail">lyh543@outlook.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/lyh543" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">汇编语言与微机接口技术 课程笔记</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">汇编语言与微机接口技术 课程笔记</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-09-08T14:52:38.000Z" itemprop="datePublished" class="page-time">
  2020-09-08
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/计算机科学/">计算机科学</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#微型计算机基础概论"><span class="post-toc-number">1.</span> <span class="post-toc-text">微型计算机基础概论</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#计算机的工作原理"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">计算机的工作原理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#微机系统组成"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">微机系统组成</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#微处理器"><span class="post-toc-number">2.</span> <span class="post-toc-text">微处理器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8086-8088-特点、工作模式"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">8086/8088 特点、工作模式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8086-8088-引线及功能"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">8086/8088 引线及功能</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#地址线和数据线"><span class="post-toc-number">2.2.1.</span> <span class="post-toc-text">地址线和数据线</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#中断请求和响应信号"><span class="post-toc-number">2.2.2.</span> <span class="post-toc-text">中断请求和响应信号</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#总线保持信号"><span class="post-toc-number">2.2.3.</span> <span class="post-toc-text">总线保持信号</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8088-和-8086-CPU-引线的差异"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">8088 和 8086 CPU 引线的差异</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8088-8086-内部结构"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">8088/8086 内部结构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8088-8086-内部寄存器"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">8088/8086 内部寄存器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#通用寄存器"><span class="post-toc-number">2.5.1.</span> <span class="post-toc-text">通用寄存器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#控制寄存器"><span class="post-toc-number">2.5.2.</span> <span class="post-toc-text">控制寄存器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#段寄存器"><span class="post-toc-number">2.5.3.</span> <span class="post-toc-text">段寄存器</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8088-8086-存储器组织"><span class="post-toc-number">2.6.</span> <span class="post-toc-text">8088/8086 存储器组织</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#8086-8088-的存储器段结构的特点"><span class="post-toc-number">2.6.1.</span> <span class="post-toc-text">8086/8088 的存储器段结构的特点</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#逻辑地址、物理地址转换"><span class="post-toc-number">2.6.2.</span> <span class="post-toc-text">逻辑地址、物理地址转换</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#堆栈"><span class="post-toc-number">2.6.3.</span> <span class="post-toc-text">堆栈</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8088-系统总线"><span class="post-toc-number">2.7.</span> <span class="post-toc-text">8088 系统总线</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#总线时序、总线周期"><span class="post-toc-number">2.7.1.</span> <span class="post-toc-text">总线时序、总线周期</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#IA-32-微处理器和工作方式"><span class="post-toc-number">2.8.</span> <span class="post-toc-text">IA-32 微处理器和工作方式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#IA-32-微处理器历史"><span class="post-toc-number">2.8.1.</span> <span class="post-toc-text">IA-32 微处理器历史</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#80286"><span class="post-toc-number">2.8.1.1.</span> <span class="post-toc-text">80286</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#80386"><span class="post-toc-number">2.8.1.2.</span> <span class="post-toc-text">80386</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#80486"><span class="post-toc-number">2.8.1.3.</span> <span class="post-toc-text">80486</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Pentium"><span class="post-toc-number">2.8.1.4.</span> <span class="post-toc-text">Pentium</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#IA-32-主要寄存器"><span class="post-toc-number">2.8.2.</span> <span class="post-toc-text">IA-32 主要寄存器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#IA-32-处理器工作方式"><span class="post-toc-number">2.8.3.</span> <span class="post-toc-text">IA-32 处理器工作方式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#实模式"><span class="post-toc-number">2.8.3.1.</span> <span class="post-toc-text">实模式</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#保护模式"><span class="post-toc-number">2.8.3.2.</span> <span class="post-toc-text">保护模式</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#虚拟-8086-模式"><span class="post-toc-number">2.8.3.3.</span> <span class="post-toc-text">虚拟 8086 模式</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#保护模式下的存储器访问"><span class="post-toc-number">2.8.3.4.</span> <span class="post-toc-text">保护模式下的存储器访问</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#本章小结"><span class="post-toc-number">2.9.</span> <span class="post-toc-text">本章小结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#指令系统"><span class="post-toc-number">3.</span> <span class="post-toc-text">指令系统</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#概述（略）"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">概述（略）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#寻址方式"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">寻址方式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#立即寻址"><span class="post-toc-number">3.2.1.</span> <span class="post-toc-text">立即寻址</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#寄存器寻址"><span class="post-toc-number">3.2.2.</span> <span class="post-toc-text">寄存器寻址</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#直接寻址"><span class="post-toc-number">3.2.3.</span> <span class="post-toc-text">直接寻址</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#寄存器间接寻址"><span class="post-toc-number">3.2.4.</span> <span class="post-toc-text">寄存器间接寻址</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#寄存器相对寻址"><span class="post-toc-number">3.2.5.</span> <span class="post-toc-text">寄存器相对寻址</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#基址-变址寻址"><span class="post-toc-number">3.2.6.</span> <span class="post-toc-text">基址-变址寻址</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#基址-变址-相对寻址"><span class="post-toc-number">3.2.7.</span> <span class="post-toc-text">基址-变址-相对寻址</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#五种寻址方式的总结"><span class="post-toc-number">3.2.8.</span> <span class="post-toc-text">五种寻址方式的总结</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#隐含寻址"><span class="post-toc-number">3.2.9.</span> <span class="post-toc-text">隐含寻址</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数据传送指令"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">数据传送指令</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#通用数据传送"><span class="post-toc-number">3.3.1.</span> <span class="post-toc-text">通用数据传送</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#一般数据传送指令-MOV"><span class="post-toc-number">3.3.1.1.</span> <span class="post-toc-text">一般数据传送指令 MOV</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#堆栈操作指令-PUSH-POP"><span class="post-toc-number">3.3.1.2.</span> <span class="post-toc-text">堆栈操作指令 PUSH POP</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#交换指令-XCHG"><span class="post-toc-number">3.3.1.3.</span> <span class="post-toc-text">交换指令 XCHG</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#字位扩展指令-CBW-CWD"><span class="post-toc-number">3.3.1.4.</span> <span class="post-toc-text">字位扩展指令 CBW CWD</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#输入输出指令-IN-OUT"><span class="post-toc-number">3.3.2.</span> <span class="post-toc-text">输入输出指令 IN OUT</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#地址传送指令-LEA-LDS-LES"><span class="post-toc-number">3.3.3.</span> <span class="post-toc-text">地址传送指令 LEA LDS LES</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#取偏移地址指令-LEA"><span class="post-toc-number">3.3.3.1.</span> <span class="post-toc-text">取偏移地址指令 LEA</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#装入地址指针指令-LDS-LES"><span class="post-toc-number">3.3.3.2.</span> <span class="post-toc-text">装入地址指针指令 LDS LES</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#标志位操作指令"><span class="post-toc-number">3.3.4.</span> <span class="post-toc-text">标志位操作指令</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#LAHF-SAHF"><span class="post-toc-number">3.3.4.1.</span> <span class="post-toc-text">LAHF SAHF</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#PUSHF-POPF"><span class="post-toc-number">3.3.4.2.</span> <span class="post-toc-text">PUSHF POPF</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#算术运算类指令"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">算术运算类指令</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#加法"><span class="post-toc-number">3.4.1.</span> <span class="post-toc-text">加法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#带符号加法-ADD"><span class="post-toc-number">3.4.1.1.</span> <span class="post-toc-text">带符号加法 ADD</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#带进位加法-ADC"><span class="post-toc-number">3.4.1.2.</span> <span class="post-toc-text">带进位加法 ADC</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#自增-INC"><span class="post-toc-number">3.4.1.3.</span> <span class="post-toc-text">自增 INC</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#减法"><span class="post-toc-number">3.4.2.</span> <span class="post-toc-text">减法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#带符号减法-SUB"><span class="post-toc-number">3.4.2.1.</span> <span class="post-toc-text">带符号减法 SUB</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#带借位减法-SBB"><span class="post-toc-number">3.4.2.2.</span> <span class="post-toc-text">带借位减法 SBB</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#自减-DEC"><span class="post-toc-number">3.4.2.3.</span> <span class="post-toc-text">自减 DEC</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#求补-NEG"><span class="post-toc-number">3.4.2.4.</span> <span class="post-toc-text">求补 NEG</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#比较-CMP"><span class="post-toc-number">3.4.2.5.</span> <span class="post-toc-text">比较 CMP</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#乘法"><span class="post-toc-number">3.4.3.</span> <span class="post-toc-text">乘法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#无符号乘法-MUL"><span class="post-toc-number">3.4.3.1.</span> <span class="post-toc-text">无符号乘法 MUL</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#带符号乘法-IMUL"><span class="post-toc-number">3.4.3.2.</span> <span class="post-toc-text">带符号乘法 IMUL</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#除法"><span class="post-toc-number">3.4.4.</span> <span class="post-toc-text">除法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#BCD-码调整指令"><span class="post-toc-number">3.4.5.</span> <span class="post-toc-text">BCD 码调整指令</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#逻辑运算和移位指令"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">逻辑运算和移位指令</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#逻辑运算"><span class="post-toc-number">3.5.1.</span> <span class="post-toc-text">逻辑运算</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#与-AND"><span class="post-toc-number">3.5.1.1.</span> <span class="post-toc-text">与 AND</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#或-OR"><span class="post-toc-number">3.5.1.2.</span> <span class="post-toc-text">或 OR</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#非-NOT"><span class="post-toc-number">3.5.1.3.</span> <span class="post-toc-text">非 NOT</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#异或-XOR"><span class="post-toc-number">3.5.1.4.</span> <span class="post-toc-text">异或 XOR</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#测试（与）-TEST"><span class="post-toc-number">3.5.1.5.</span> <span class="post-toc-text">测试（与） TEST</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#移位指令"><span class="post-toc-number">3.5.2.</span> <span class="post-toc-text">移位指令</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#算术左移-SAL-逻辑左移-SHL"><span class="post-toc-number">3.5.2.1.</span> <span class="post-toc-text">算术左移 SAL 逻辑左移 SHL</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#算术右移-SAR-逻辑右移-SHR"><span class="post-toc-number">3.5.2.2.</span> <span class="post-toc-text">算术右移 SAR 逻辑右移 SHR</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#不带-CF-的循环移位-ROL-ROR"><span class="post-toc-number">3.5.2.3.</span> <span class="post-toc-text">不带 CF 的循环移位 ROL ROR</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#带-CF-的循环移位-RCL-RCR"><span class="post-toc-number">3.5.2.4.</span> <span class="post-toc-text">带 CF 的循环移位 RCL RCR</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#串操作指令"><span class="post-toc-number">3.6.</span> <span class="post-toc-text">串操作指令</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#特点"><span class="post-toc-number">3.6.1.</span> <span class="post-toc-text">特点</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#重复前缀"><span class="post-toc-number">3.6.2.</span> <span class="post-toc-text">重复前缀</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#串操作指令流程"><span class="post-toc-number">3.6.3.</span> <span class="post-toc-text">串操作指令流程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#串传送指令-MOVS"><span class="post-toc-number">3.6.4.</span> <span class="post-toc-text">串传送指令 MOVS</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#串比较指令-CMPS"><span class="post-toc-number">3.6.5.</span> <span class="post-toc-text">串比较指令 CMPS</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#串扫描指令-SCAS"><span class="post-toc-number">3.6.6.</span> <span class="post-toc-text">串扫描指令 SCAS</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#串装入指令-LODS"><span class="post-toc-number">3.6.7.</span> <span class="post-toc-text">串装入指令 LODS</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#串存储指令-STOS"><span class="post-toc-number">3.6.8.</span> <span class="post-toc-text">串存储指令 STOS</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#串操作指令注意事项"><span class="post-toc-number">3.6.9.</span> <span class="post-toc-text">串操作指令注意事项</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#程序控制指令"><span class="post-toc-number">3.7.</span> <span class="post-toc-text">程序控制指令</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#程序的执行方向"><span class="post-toc-number">3.7.1.</span> <span class="post-toc-text">程序的执行方向</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#转移指令-JMP"><span class="post-toc-number">3.7.2.</span> <span class="post-toc-text">转移指令 JMP</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#无条件转移指令"><span class="post-toc-number">3.7.2.1.</span> <span class="post-toc-text">无条件转移指令</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#段内转移"><span class="post-toc-number">3.7.2.1.1.</span> <span class="post-toc-text">段内转移</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#段间转移-JMP-FAR"><span class="post-toc-number">3.7.2.1.2.</span> <span class="post-toc-text">段间转移 JMP FAR</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#条件转移指令"><span class="post-toc-number">3.7.2.2.</span> <span class="post-toc-text">条件转移指令</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#循环控制指令"><span class="post-toc-number">3.7.3.</span> <span class="post-toc-text">循环控制指令</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#无条件循环指令-LOOP"><span class="post-toc-number">3.7.3.1.</span> <span class="post-toc-text">无条件循环指令 LOOP</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#有条件循环指令-LOOPZ-LOOPNZ（略）"><span class="post-toc-number">3.7.3.2.</span> <span class="post-toc-text">有条件循环指令 LOOPZ LOOPNZ（略）</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#过程调用指令-CALL"><span class="post-toc-number">3.7.4.</span> <span class="post-toc-text">过程调用指令 CALL</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#段内调用-CALL-NEAR"><span class="post-toc-number">3.7.4.1.</span> <span class="post-toc-text">段内调用 CALL NEAR</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#段间调用-CALL-FAR"><span class="post-toc-number">3.7.4.2.</span> <span class="post-toc-text">段间调用 CALL FAR</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#返回指令-RET"><span class="post-toc-number">3.7.4.3.</span> <span class="post-toc-text">返回指令 RET</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#中断控制指令"><span class="post-toc-number">3.7.5.</span> <span class="post-toc-text">中断控制指令</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#中断和过程调用的区别"><span class="post-toc-number">3.7.5.1.</span> <span class="post-toc-text">中断和过程调用的区别</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#中断指令-INT"><span class="post-toc-number">3.7.5.2.</span> <span class="post-toc-text">中断指令 INT</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#中断指令的执行过程"><span class="post-toc-number">3.7.5.3.</span> <span class="post-toc-text">中断指令的执行过程</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#溢出中断指令-INTO"><span class="post-toc-number">3.7.5.4.</span> <span class="post-toc-text">溢出中断指令 INTO</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#中断返回指令-ITER"><span class="post-toc-number">3.7.5.5.</span> <span class="post-toc-text">中断返回指令 ITER</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#处理器控制指令"><span class="post-toc-number">3.7.6.</span> <span class="post-toc-text">处理器控制指令</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#汇编语言程序设计"><span class="post-toc-number">4.</span> <span class="post-toc-text">汇编语言程序设计</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#汇编语言语句种类及其格式"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">汇编语言语句种类及其格式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#指令语句"><span class="post-toc-number">4.1.1.</span> <span class="post-toc-text">指令语句</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#伪指令语句"><span class="post-toc-number">4.1.2.</span> <span class="post-toc-text">伪指令语句</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#标识符"><span class="post-toc-number">4.1.3.</span> <span class="post-toc-text">标识符</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#保留字"><span class="post-toc-number">4.1.4.</span> <span class="post-toc-text">保留字</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#汇编语言数据"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">汇编语言数据</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#常数"><span class="post-toc-number">4.2.1.</span> <span class="post-toc-text">常数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#常量的表示"><span class="post-toc-number">4.2.1.1.</span> <span class="post-toc-text">常量的表示</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#常数的作用"><span class="post-toc-number">4.2.1.2.</span> <span class="post-toc-text">常数的作用</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#变量"><span class="post-toc-number">4.2.2.</span> <span class="post-toc-text">变量</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#变量的定义"><span class="post-toc-number">4.2.2.1.</span> <span class="post-toc-text">变量的定义</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#变量的属性"><span class="post-toc-number">4.2.2.2.</span> <span class="post-toc-text">变量的属性</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#变量的预置"><span class="post-toc-number">4.2.2.3.</span> <span class="post-toc-text">变量的预置</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#数值表达式"><span class="post-toc-number">4.2.2.3.1.</span> <span class="post-toc-text">数值表达式</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#表达式"><span class="post-toc-number">4.2.2.3.2.</span> <span class="post-toc-text">? 表达式</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#字符串表达式"><span class="post-toc-number">4.2.2.3.3.</span> <span class="post-toc-text">字符串表达式</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#DUP-表达式"><span class="post-toc-number">4.2.2.3.4.</span> <span class="post-toc-text">DUP 表达式</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#地址表达式"><span class="post-toc-number">4.2.2.3.5.</span> <span class="post-toc-text">地址表达式</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#以上表达式组成的序列"><span class="post-toc-number">4.2.2.3.6.</span> <span class="post-toc-text">以上表达式组成的序列</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#变量的使用"><span class="post-toc-number">4.2.2.4.</span> <span class="post-toc-text">变量的使用</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#符号和变量对比"><span class="post-toc-number">4.2.2.5.</span> <span class="post-toc-text">符号和变量对比</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#标号"><span class="post-toc-number">4.2.3.</span> <span class="post-toc-text">标号</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#标号的三个属性"><span class="post-toc-number">4.2.3.1.</span> <span class="post-toc-text">标号的三个属性</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#LABEL-定义变量属性"><span class="post-toc-number">4.2.3.2.</span> <span class="post-toc-text">LABEL 定义变量属性</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#符号定义语句"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">符号定义语句</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#等值语句-EQU"><span class="post-toc-number">4.3.1.</span> <span class="post-toc-text">等值语句 EQU</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#等号语句"><span class="post-toc-number">4.3.2.</span> <span class="post-toc-text">等号语句 =</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#表达式与运算符"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">表达式与运算符</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#算术运算符"><span class="post-toc-number">4.4.1.</span> <span class="post-toc-text">算术运算符</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#逻辑运"><span class="post-toc-number">4.4.2.</span> <span class="post-toc-text">逻辑运</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#关系运算符"><span class="post-toc-number">4.4.3.</span> <span class="post-toc-text">关系运算符</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#数值返回运算符"><span class="post-toc-number">4.4.4.</span> <span class="post-toc-text">数值返回运算符</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#SEG-运算符"><span class="post-toc-number">4.4.4.1.</span> <span class="post-toc-text">SEG 运算符</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#OFFSET-运算符"><span class="post-toc-number">4.4.4.2.</span> <span class="post-toc-text">OFFSET 运算符</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#TYPE-运算符"><span class="post-toc-number">4.4.4.3.</span> <span class="post-toc-text">TYPE 运算符</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#LENGTH-运算符"><span class="post-toc-number">4.4.4.4.</span> <span class="post-toc-text">LENGTH 运算符</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#SIZE-运算符"><span class="post-toc-number">4.4.4.5.</span> <span class="post-toc-text">SIZE 运算符</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#属性修改运算符"><span class="post-toc-number">4.4.5.</span> <span class="post-toc-text">属性修改运算符</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#PTR-运算符"><span class="post-toc-number">4.4.5.1.</span> <span class="post-toc-text">PTR 运算符</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#HIGH-LOW"><span class="post-toc-number">4.4.5.2.</span> <span class="post-toc-text">HIGH/LOW</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#运算符的优先级"><span class="post-toc-number">4.4.6.</span> <span class="post-toc-text">运算符的优先级</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#程序的段结构"><span class="post-toc-number">4.5.</span> <span class="post-toc-text">程序的段结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#段定义伪指令-SEGMENT"><span class="post-toc-number">4.5.1.</span> <span class="post-toc-text">段定义伪指令 SEGMENT</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#段名"><span class="post-toc-number">4.5.1.1.</span> <span class="post-toc-text">段名</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#定位类型"><span class="post-toc-number">4.5.1.2.</span> <span class="post-toc-text">定位类型</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#组合类型"><span class="post-toc-number">4.5.1.3.</span> <span class="post-toc-text">组合类型</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#类别名"><span class="post-toc-number">4.5.1.4.</span> <span class="post-toc-text">类别名</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#段寻址伪指令-ASSUME"><span class="post-toc-number">4.5.2.</span> <span class="post-toc-text">段寻址伪指令 ASSUME</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#段寄存器的装入"><span class="post-toc-number">4.5.3.</span> <span class="post-toc-text">段寄存器的装入</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#过程定义伪指令-PROC"><span class="post-toc-number">4.6.</span> <span class="post-toc-text">过程定义伪指令 PROC</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#当前位置计数器-与定位伪指令-ORG"><span class="post-toc-number">4.7.</span> <span class="post-toc-text">当前位置计数器 $ 与定位伪指令 ORG</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-computer-science/assembly-language-and-interface-technology-of-microcomputer-classnote"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">汇编语言与微机接口技术 课程笔记</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-09-08 14:52:38" datetime="2020-09-08T14:52:38.000Z"  itemprop="datePublished">2020-09-08</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/计算机科学/">计算机科学</a></li></ul>



            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <ul>
<li>授课老师：廖建明老师</li>
<li>教材：《微机原理与接口技术》(第4版). 吴宁,乔亚男主编. 清华大学出版社</li>
<li>参考教材:《汇编语言程序设计》. 廖建明主编.清华大学出版社</li>
</ul>
<h2 id="微型计算机基础概论"><a href="#微型计算机基础概论" class="headerlink" title="微型计算机基础概论"></a>微型计算机基础概论</h2><h3 id="计算机的工作原理"><a href="#计算机的工作原理" class="headerlink" title="计算机的工作原理"></a>计算机的工作原理</h3><p>计算机中的指令执行过程：取指令 -&gt; 指令译码 -&gt; 读取操作数 -&gt; 执行命令 -&gt; 存放结果</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/2b125ce6885b6eddbe43b0c1b94ea20d5b0f18a475587854d4bda793f548e73f.png" alt="计算机基本组成结构" title>
                </div>
                <div class="image-caption">计算机基本组成结构</div>
            </figure>  

<p>指令的顺序工作方式和并行流水线工作方式</p>
<ul>
<li>冯 • 诺依曼计算机的工作原理：<ul>
<li>存储程序工作方式</li>
<li>运算器为核心</li>
</ul>
</li>
<li>特点：<ul>
<li>存储程序，共享数据，顺序执行；</li>
<li>属于顺序处理机，适于确定的算法和数值处理。</li>
</ul>
</li>
<li>不足：<ul>
<li>与存储器间有大量数据交互，对总线要求很高；</li>
<li>执行顺序由程序决定，对大型复杂任务较难处理；</li>
<li>以运算器为核心，处理效率较低；<br>由PC控制执行顺序，难以进行真正的并行处理。</li>
</ul>
</li>
</ul>
<p>非冯 • 诺依曼计算机：并行性</p>
<h3 id="微机系统组成"><a href="#微机系统组成" class="headerlink" title="微机系统组成"></a>微机系统组成</h3><ul>
<li>微处理器：<strong>运算器单元+控制器单元+寄存器单元+内部总线</strong>，具有CPU全部功能的大规模集成电路芯片。</li>
<li>微型机：<strong>微处理器+内存+I/O接口+系统总线+电源+输入/输出设备+外存设备</strong></li>
<li>微机系统：<strong>微型机+系统软件+应用软件</strong></li>
</ul>
<h2 id="微处理器"><a href="#微处理器" class="headerlink" title="微处理器"></a>微处理器</h2><h3 id="8086-8088-特点、工作模式"><a href="#8086-8088-特点、工作模式" class="headerlink" title="8086/8088 特点、工作模式"></a>8086/8088 特点、工作模式</h3><p>特点：并行流水线、内存空间分段管理、多处理器系统</p>
<p>工作模式：最小（单处理器，不必接总线控制器）/最大（多处理器，需总线控制器）</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/7ad14e65b5c37de1842d043b016c76a8d3bd32ce0a7851e280bdc84c13ebcb99.png" alt="最小模式下的总线连接示意图" title>
                </div>
                <div class="image-caption">最小模式下的总线连接示意图</div>
            </figure>  


<p><img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/155a118f5171dbabacdf915d12b68eaa987f1b740a9d36ddda8463d00aebb92e.png" alt="最大模式下的总线连接示意图"></p>
<p>工作模式选择：$MN/\overline{MX}$引脚</p>
<ul>
<li>$MN/\overline{MX}=0$：最大模式</li>
<li>$MN/\overline{MX}=1$：最小模式</li>
</ul>
<h3 id="8086-8088-引线及功能"><a href="#8086-8088-引线及功能" class="headerlink" title="8086/8088 引线及功能"></a>8086/8088 引线及功能</h3><h4 id="地址线和数据线"><a href="#地址线和数据线" class="headerlink" title="地址线和数据线"></a>地址线和数据线</h4><ul>
<li>AD0-AD7：低 8 位地址和低 8 位数据信号（分时复用）。传送地址时单向，传送数据时双</li>
<li>A8-A15：8位地址信号</li>
<li>A16-A19/S3-S6：高4位地址信号，与状态信号分时复用<ul>
<li>$\overline{WR}$：写信号</li>
<li>$\overline{RD}$：读信号</li>
<li>$IO/\overline{M}$：访问内存/访问接口</li>
<li>$\overline{DEN}$：低电平有效时，数据总线上数据有效，允许进行读/写操作</li>
<li>$DT/\overline{R}$(Data Transmit/ Receive)：为“1”时 CPU 向存储器或 I/O 传送，否则为反向</li>
<li>ALE：地址锁存信号，当其为高时表示地址线上地址有效。一般用它将地址锁存到一个锁存器中</li>
<li>RESET：复位信号。当其为高时将完成CPU内部复位。复位后CPU内部寄存器的值如下表</li>
</ul>
</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/6496134227c8788122f9189f659d55960174a1226f8bdb7595368e5b24ee7f3d.png" alt="复位后 CPU 的内部寄存器状态" title>
                </div>
                <div class="image-caption">复位后 CPU 的内部寄存器状态</div>
            </figure>  

<p><img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/400c11160d21c24a4001d80071e2fef1906a764604fe8d687d74affc03defa92.png" alt="例题">  </p>
<ul>
<li>READY：外部同步控制输入信号，高电平有效（8088 与内存/外设之间在一个总线周期内的时钟配合信号）</li>
</ul>
<h4 id="中断请求和响应信号"><a href="#中断请求和响应信号" class="headerlink" title="中断请求和响应信号"></a>中断请求和响应信号</h4><ul>
<li>INTR：可屏蔽中断请求输入端</li>
<li>NMI： 非屏蔽中断请求输入端</li>
<li>$\overline{INTA}$：中断响应输出端</li>
</ul>
<h4 id="总线保持信号"><a href="#总线保持信号" class="headerlink" title="总线保持信号"></a>总线保持信号</h4><ul>
<li>HOLD：总线保持请求信号输入端。当 CPU 以外的其他设备要求占用总线时，通过该引脚向 CPU 发出请求（外设 -&gt; CPU）</li>
<li>HLDA：总线保持响应信号输出端。CPU 对 HOLD 信号的响应信号（CPU -&gt; 外设）</li>
</ul>
<h3 id="8088-和-8086-CPU-引线的差异"><a href="#8088-和-8086-CPU-引线的差异" class="headerlink" title="8088 和 8086 CPU 引线的差异"></a>8088 和 8086 CPU 引线的差异</h3><ul>
<li>数据总线宽度不同<ul>
<li>8088的外部总线宽度是8位，8086为16位。</li>
</ul>
</li>
<li>访问存储器和I/O控制的信号含义不<ul>
<li>8088——$IO/\overline{M}=0$ 表示访问内存；</li>
<li>8086——$IO/\overline{M}=1$ 表示访问内存。</li>
</ul>
</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/98680035b5a29445842f7489e2f5bfc56cebba8a27c8b951523eca8fae9fcf61.png" alt="段寄存器" title>
                </div>
                <div class="image-caption">段寄存器</div>
            </figure> 

<h3 id="8088-8086-内部结构"><a href="#8088-8086-内部结构" class="headerlink" title="8088/8086 内部结构"></a>8088/8086 内部结构</h3><ul>
<li>执行单元 EU</li>
<li>总线接口单元 BIU</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/cafe7330e111a3f1db574ccbf7a1fcd0f4a47c03fd9cb14a0f846ce6a3066737.png" alt="8086CPU结构" title>
                </div>
                <div class="image-caption">8086CPU结构</div>
            </figure>  

<p>执行单元 EU</p>
<ul>
<li>组成：<ul>
<li>ALU</li>
<li>8 个通用寄存器</li>
<li>1 个标志寄存器</li>
<li>EU 部分的控制电路</li>
</ul>
</li>
<li>功能：<ul>
<li>指令译码</li>
<li>指令执行</li>
<li>暂存中间运算结果</li>
<li>保存运算结果特征</li>
</ul>
</li>
</ul>
<p>总线接口单元 BIU</p>
<ul>
<li>组成：<ul>
<li>地址加法器</li>
<li>4 个段寄存器</li>
<li>指令指针 IP</li>
<li>总线控制逻辑</li>
</ul>
</li>
<li>功能：<ul>
<li>从内存中取指令到指令队列（指令队列是并行流水线工作的基础）</li>
<li>负责与内存或 I/O 接口之间的数据传送</li>
<li>在执行转移程序时，BIU 清除指令队列，从指定的新地址取指令，并立即传给执行单元执行</li>
</ul>
</li>
</ul>
<h3 id="8088-8086-内部寄存器"><a href="#8088-8086-内部寄存器" class="headerlink" title="8088/8086 内部寄存器"></a>8088/8086 内部寄存器</h3><ul>
<li>16 位寄存器<ul>
<li>8个通用寄存器</li>
<li>4个段寄存器</li>
<li>2个控制寄存器</li>
</ul>
</li>
</ul>
<h4 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h4><ul>
<li>数据寄存器：AX、BX、CX、DX<ul>
<li>AX 分为 <code>AH:AL</code>，以此类推</li>
<li>AX: Add</li>
<li>BX: Base 基址寄存器</li>
<li>CX: Count 计数</li>
<li>DX: Data<ul>
<li>在间接寻址的 I/O 指令中存放 I/O 端口地址</li>
<li>在 32 位乘除法运算时，存高 16 位数</li>
</ul>
</li>
</ul>
</li>
<li>地址指针寄存器：SP、BP<ul>
<li>SP: Stack 栈顶的偏移地址</li>
<li>BP: Base 基址指针寄存器，访问内存时存放内存单元的偏移地址<ul>
<li>BX BP 作为通用寄存器，二者均可用于存放数据</li>
<li>作为基址寄存器，用 BX 表示所寻找的数据在数据段；用 BP 则表示数据在堆栈段</li>
</ul>
</li>
</ul>
</li>
<li>变址寄存器 <code>Index Register</code>：SI、DI 存放数据在内存中的地址<ul>
<li>SI 源</li>
<li>DI 目标</li>
</ul>
</li>
</ul>
<h4 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h4><ul>
<li>IP：指令指针寄存器，其内容为下一条要执行指令的偏移地址</li>
<li>FLAGS：CF、SF、AF、PF、OF、ZF、IF、TF、DF<ul>
<li>CF：进位标志位</li>
<li>SF：符号标志位</li>
<li>AF：辅助 CF。若 Bit3 向 Bit4 有进位(借位)，AF=1<ul>
<li>Bit 号从 0 开始，用中文描述就是第四位向第五位有进位。</li>
<li>在 16 位加法中，AF 仍然是 Bit3 向 Bit4 进位的结果。详见 <a href="https://stackoverflow.com/questions/36492553/how-to-set-auxiliary-flag-for-16bits-binary-addition" target="_blank" rel="noopener">assembly - how to set auxiliary flag for 16bits binary addition - Stack Overflow</a></li>
</ul>
</li>
<li>PF：奇偶标志位，运算结果的低 8 位中 <code>1</code> 的个数为偶数时 PF=1</li>
<li>OF：溢出标志位</li>
<li>ZF：零标志位</li>
<li>TF：陷阱标志位，TF=1 使 CPU 处于单步执行指令</li>
<li>IF：允许中断标志位</li>
<li>DF：方向标志位。在数据串操作时确定操作的方向。</li>
</ul>
</li>
</ul>
<p><img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/a52f6b563d277084286fabdc71037dc19a5d732c34de36e070670376d34ef179.png" alt="例题">  </p>
<h4 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h4><ul>
<li>作用：用于存放相应逻辑段的段基地址</li>
<li>8086/8088 内存中逻辑段的类型：代码段、数据段、附加段、堆栈段</li>
<li>8086/8088 内存中逻辑段的数量<ul>
<li>最多为 64K 个</li>
<li>程序中同时可以使用4个段，分别由CS、DS、ES和SS四个段寄存器指示。</li>
</ul>
</li>
<li>CS：代码段寄存器，存放代码段的段基地址。</li>
<li>DS：数据段寄存器，存放数据段的段基地址。</li>
<li>ES：附加段寄存器，存放数据段的段基地址。</li>
<li>SS：堆栈段寄存器，存放堆栈段的段基地址。</li>
</ul>
<h3 id="8088-8086-存储器组织"><a href="#8088-8086-存储器组织" class="headerlink" title="8088/8086 存储器组织"></a>8088/8086 存储器组织</h3><p>内存地址：物理地址、逻辑地址</p>
<p>物理地址：8086/8088CPU有20根地址线，它可以产生20位的地址码，寻址范围为220，即1兆字节空间。</p>
<p>字单元：任何两个相邻字节单元构成，16 bits</p>
<ul>
<li>子单元地址：字节较小地址</li>
<li>存放规则：小端</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/0b6da650308dced8aadba7cd9c0fed64fd1c1ec9ee3231a82918654770f4a920.png" alt="例题" title>
                </div>
                <div class="image-caption">例题</div>
            </figure>  

<ul>
<li>32-bit 逻辑地址 = 16-bit 段基地址 <code>拼接</code> 16-bit 段内地址</li>
<li>16-bit 物理地址：16-bit 段基地址 <code>*16+</code> 16-bit 偏移地址<ul>
<li>段首的偏移地址 = <code>0000</code></li>
</ul>
</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/468d81f9a1623be2e0ff52fa5f0910af4f05b6e3ec0bf0d92df5611edcdad93c.png" alt="例题" title>
                </div>
                <div class="image-caption">例题</div>
            </figure>  

<h4 id="8086-8088-的存储器段结构的特点"><a href="#8086-8088-的存储器段结构的特点" class="headerlink" title="8086/8088 的存储器段结构的特点"></a>8086/8088 的存储器段结构的特点</h4><ol>
<li>段大小 &lt;= 64KB</li>
<li>段首地址为一个小节的首地址<ul>
<li>小节：每 16 Bytes 为一小节</li>
<li>小节的首地址最低位为 <code>0000</code></li>
</ul>
</li>
<li>逻辑段在物理可邻接的、间隔的、部分重叠的和完全重叠的</li>
<li>在任一时刻，一个程序只能访问4个<a href="#段寄存器">当前段</a>中的内容</li>
</ol>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/637600cc1fa7d7355b08efe783b6db99f560352a79bdad2cc637429962eeecfe.png" alt="例题" title>
                </div>
                <div class="image-caption">例题</div>
            </figure>  

<h4 id="逻辑地址、物理地址转换"><a href="#逻辑地址、物理地址转换" class="headerlink" title="逻辑地址、物理地址转换"></a>逻辑地址、物理地址转换</h4><p><strong>物理地址 = 段基地址 &lt;&lt; 4 + 偏移地址</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/5f6126651c2f92a12a399a23042e32e90604a3789775ee239e68fd6f8b9ef288.png" alt="例题" title>
                </div>
                <div class="image-caption">例题</div>
            </figure>  

<h4 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h4><p>堆栈：</p>
<ul>
<li>特定的存储区，访问该存储区一般需要按照专门的规则进行操作</li>
<li>主要用于暂存数据以及在过程调用或处理中断时保存断点信息</li>
<li>一般分为<strong>专用堆栈存储器</strong>和<strong>软件堆栈</strong><ul>
<li>专用堆栈存储器：按堆栈的工作方式专门设计的存储器</li>
<li>软件堆栈：由程序设计人员用软件在内存中划出的一块存储区作为堆栈来使用。8086/8088采用这种方式。<br>堆栈组成：</li>
</ul>
</li>
<li>栈底：固定，是堆栈存储区最大地址单元</li>
<li>栈顶：浮动，是最后存入信息的存储单元</li>
<li>栈顶指针 SP：指示栈顶单元</li>
<li>数据在堆栈中以字（16 bits）为单位小端存放</li>
<li><strong>初始化时，SP = 栈底 + 2 = 堆栈长度</strong></li>
<li>堆栈长度 &lt;= 64KB</li>
<li>SP 始终表示堆栈段基址与栈顶之间的距离</li>
<li>程序设置多个堆栈段</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/64c036d835f462697d02fab06b3524811e1605b5cd80c872d5aef524a496b8e4.png" alt="堆栈" title>
                </div>
                <div class="image-caption">堆栈</div>
            </figure>  

<p><img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/3232f210c17ae3c8dcf5384bf31e3a457ab22a7a88caa61a1c862f07d3c62488.png" alt="例题">  </p>
<h3 id="8088-系统总线"><a href="#8088-系统总线" class="headerlink" title="8088 系统总线"></a>8088 系统总线</h3><p>总线 <code>Bus</code>：是一组<strong>导线</strong>和相关的<strong>控制、驱动电路</strong>的集合，它是计算机系统各部件之间<strong>传输地址、数据和控制信息</strong>的通道。</p>
<p>分类：</p>
<ul>
<li>地址总线 AB</li>
<li>数据总线 DB</li>
<li>控制总线 CB</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/77fefbfe1c701322f95e03a68a9212d17f7de87ad156678cc4add7ee1d9b6665.png" alt="最小模式下的系统总线" title>
                </div>
                <div class="image-caption">最小模式下的系统总线</div>
            </figure>  

<p>最小模式下不需要 8288 总线控制器，而最大模式下需要。</p>
<ul>
<li>8282：锁存器，连接地址线（因为要和数据线复用，所以要配合 ALE 将地址存进锁存器）</li>
<li>8284：时钟发生器</li>
<li>8286：双向总线驱动器，连接（内外部的）数据总线</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/99150753542d61ed4eb265a6a2dd0cd31be1d9d30ddc3bbfbf4ed264a76d7563.png" alt="最大模式下的系统总线" title>
                </div>
                <div class="image-caption">最大模式下的系统总线</div>
            </figure>  

<ul>
<li>8288：总线控制器，支持 CPU</li>
</ul>
<h4 id="总线时序、总线周期"><a href="#总线时序、总线周期" class="headerlink" title="总线时序、总线周期"></a>总线时序、总线周期</h4><ul>
<li>时序：CPU各引脚信号在时间上的关系</li>
<li>总线周期：CPU 完成一次访问内存(或I/O接口)操作所需要的时间<ul>
<li>一个总线周期至少包括 4 个时钟周期</li>
</ul>
</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/64806a8d406e61c0d8767705627eb3d62880eb95146547c02b9069fa3f1e3081.png" alt="8088最小模式下的读周期" title>
                </div>
                <div class="image-caption">8088最小模式下的读周期</div>
            </figure>

<ul>
<li>T1上 输出地址</li>
<li>T1下 锁地址</li>
<li>T2 输出状态，给 $\overline{RD}$、$\overline{DEN}$</li>
<li>T3 输入数据</li>
<li>T4 复位，关状态输出</li>
</ul>
<p>但这个状态在最小模式中没有用，在最大模式中才会用到（</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/b548bde2652a6b919ff10a3ca85fbe324b33efbaf64d64fe059b59982ee3c548.png" alt="8088最小模式下的写周期" title>
                </div>
                <div class="image-caption">8088最小模式下的写周期</div>
            </figure>

<p>写的区别除了 $\overline{WR}$、$DT/\overline{R}$、外，还有 AD 线在地址输出结束后必须立即数据输出。</p>
<h3 id="IA-32-微处理器和工作方式"><a href="#IA-32-微处理器和工作方式" class="headerlink" title="IA-32 微处理器和工作方式"></a>IA-32 微处理器和工作方式</h3><p>Intel公司将 80286 之后的 80X86 32 位微处理器称为 IA(Intel Architecture)-32 结构（现在是 AMD64）</p>
<h4 id="IA-32-微处理器历史"><a href="#IA-32-微处理器历史" class="headerlink" title="IA-32 微处理器历史"></a>IA-32 微处理器历史</h4><h5 id="80286"><a href="#80286" class="headerlink" title="80286"></a>80286</h5><ul>
<li>实地址模式、虚地址保护模式</li>
<li>CPU 被分为：<ul>
<li>总线部件 <code>BU</code></li>
<li>地址部件 <code>AU</code></li>
<li>执行部件 <code>EU</code></li>
<li>指令部件 <code>IU</code></li>
</ul>
</li>
</ul>
<h5 id="80386"><a href="#80386" class="headerlink" title="80386"></a>80386</h5><ul>
<li>实地址模式、保护模式和虚拟 8086 模式</li>
<li>CPU 被分为：<ul>
<li>总线接口单元 <code>BIU</code></li>
<li>指令预取单元 <code>IPU</code></li>
<li>指令译码单元 <code>IDU</code></li>
<li>执行单元 <code>EU</code></li>
<li>分段单元 <code>SU</code></li>
<li>分页单元 <code>PU</code></li>
</ul>
</li>
<li>分页存储</li>
</ul>
<h5 id="80486"><a href="#80486" class="headerlink" title="80486"></a>80486</h5><ul>
<li>突发传送方式（成块数据传送）</li>
</ul>
<h5 id="Pentium"><a href="#Pentium" class="headerlink" title="Pentium"></a>Pentium</h5><ul>
<li>与80X86系列微处理器兼容</li>
<li>RISC型超标量结构（处理器包含多个指令单元和指令流水线）</li>
<li>高性能浮点运算器</li>
<li>双重分离式高速缓存（分离指令缓存和数据缓存）</li>
<li>64位数据总线</li>
<li>分支指令预测</li>
<li>常用指令固化与微代码改进（把常用的指令改用硬件实现，而不使用微程序方式）</li>
<li>系统管理方式程序 <code>SMM</code>（电源管理、为操作系统和正在运行的程序提供安全性）</li>
</ul>
<h4 id="IA-32-主要寄存器"><a href="#IA-32-主要寄存器" class="headerlink" title="IA-32 主要寄存器"></a>IA-32 主要寄存器</h4><p>通用寄存器：8 个 32 位通用寄存器</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/053fb371fb6454e749e0b163a18e8e20a4f10f5ceb7a3dd32f021e19c821f50f.png" alt="通用寄存器" title>
                </div>
                <div class="image-caption">通用寄存器</div>
            </figure>  

<p>指令指针和标志寄存器：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/48c324c8082d27de0d88346a4f03c24cb3b9da3e5e30b1b3f1a265a52aeb198c.png" alt="指令指针和标志寄存器" title>
                </div>
                <div class="image-caption">指令指针和标志寄存器</div>
            </figure>  

<p>段寄存器和系统地址寄存器：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/185bcf860d26194ac5ff1dcc95bc396fdec6ee583de45f5150c77e8e38bfd9f5.png" alt="段寄存器和系统地址寄存器" title>
                </div>
                <div class="image-caption">段寄存器和系统地址寄存器</div>
            </figure>  

<p>控制寄存器：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/97454c165ea943f277fbbf346f091226dd54d155a0678fdd453919ae592e4780.png" alt="控制寄存器" title>
                </div>
                <div class="image-caption">控制寄存器</div>
            </figure>  

<h4 id="IA-32-处理器工作方式"><a href="#IA-32-处理器工作方式" class="headerlink" title="IA-32 处理器工作方式"></a>IA-32 处理器工作方式</h4><h5 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h5><ul>
<li>兼容 8086</li>
<li>32条地址线中只有低20条地址线起作用，可寻址1MB的物理地址空间</li>
<li>无多任务处理</li>
</ul>
<h5 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h5><ul>
<li>32条地址可寻址4GB的物理存储器空间</li>
<li>支持虚拟存储器功能。每个任务运行可以有16K个段，每个段最大为4GB，一个任务最大可使用64TB虚拟地址空间</li>
<li>程序运行分为4个特权等级，操作系统核心运行在最高特权级0，用户程序运行在最低特权级3</li>
</ul>
<h5 id="虚拟-8086-模式"><a href="#虚拟-8086-模式" class="headerlink" title="虚拟 8086 模式"></a>虚拟 8086 模式</h5><ul>
<li>在虚拟8086方式下，IA-32微处理器总体上是工作在保护虚地址方式，支持多用户多任务操作系统。其中，有的任务可以工作在虚拟8086方式，运行DOS应用程序。 </li>
</ul>
<h5 id="保护模式下的存储器访问"><a href="#保护模式下的存储器访问" class="headerlink" title="保护模式下的存储器访问"></a>保护模式下的存储器访问</h5><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/2fbb6ff64908cc7b0d609d1ba77d9a3353734cdcb4e49274614eceb091f15273.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>  
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/d857aaca3e3dff84edbd0a230fe994898971b8d736b5cf940ef3848e12988443.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>  
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/9b4089dedd698d5d3c336282839346d84df2928f47f32a7e9eec7da59bfed41d.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>  
<p>!8](<a href="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/aa43a063892450e1db26d246ecfdcb8633f71176b8c300c906f4fc07370f17d3.png" target="_blank" rel="noopener">https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/aa43a063892450e1db26d246ecfdcb8633f71176b8c300c906f4fc07370f17d3.png</a>)<br><img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/a4d3d11ebac6286de0ea91217c9941d71fce115a37ebc3c65a91302fe8cda623.png" alt>  </p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/c298ac75a7755956f0b65e0222ade4838590cb5b0a50fbe9c0f103803996a4c7.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>  
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/313ab77109d17290d961fac8dab9a4dca36e1ab3282568bcecea8c4949e1b12f.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>  
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/9d6ae3513ebf9224b7268780a93e05b6b4a1d70762be0212b6e991f7934fc20a.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>  


<h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/f7908757260263ea785a2ea08addf225754d8b67ea31c51c5dd02b93306dce11.png" alt="本章小结" title>
                </div>
                <div class="image-caption">本章小结</div>
            </figure>  

<p>8088 相关知识：</p>
<ul>
<li>地址线、数据线、控制线若干</li>
<li>16 位寄存器（各个的中文？）<ul>
<li>8个通用寄存器：AX、BX、CX、DX、SP、BP、SI、DI</li>
<li>4个段寄存器：CS、DS、ES、SS</li>
<li>2个控制寄存器：IP、FLAGS (CF、SF、AF、PF、OF、ZF、IF、TF、DF)</li>
</ul>
</li>
<li>存储器<ul>
<li>32-bit 逻辑地址 = 16-bit 段基地址 <code>拼接</code> 16-bit 段内地址</li>
<li>16-bit 物理地址：16-bit 段基地址 <code>*16+</code> 16-bit 偏移地址</li>
</ul>
</li>
<li>堆栈：栈底固定，为地址最大值；以字为单位</li>
</ul>
<h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><h3 id="概述（略）"><a href="#概述（略）" class="headerlink" title="概述（略）"></a>概述（略）</h3><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p>这里讲的是 8086 的寻址方式，《计算机组成原理》讲的是 MIPS 的，因此会有区别。</p>
<p>除了立即寻址、寄存器寻址、隐含寻址，其余寻址方式都是得到 <code>偏移地址</code> 以后 <code>+16*段地址</code> 得出，并且这些方式都会加 <code>[ ]</code>。</p>
<h4 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/81aee00541b6ed26f57a285dfca95ed8bfc39ea105dbbbebf22a990d8eb52243.png" alt="立即寻址" title>
                </div>
                <div class="image-caption">立即寻址</div>
            </figure>  

<h4 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/080823908581cf98753c95657c5977caa9527af6badf435488b8a85f259ebf59.png" alt="寄存器寻址" title>
                </div>
                <div class="image-caption">寄存器寻址</div>
            </figure>  

<h4 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h4><p>偏移地址 = 立即数</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/cd909019497371be41e17abadc1a7d8a5d78f524873fe4445d3ecb2ddea1148d.png" alt="直接寻址" title>
                </div>
                <div class="image-caption">直接寻址</div>
            </figure>  

<ul>
<li>直接寻址下，存储器操作数的长度由指令中另一个操作数的长度决定。如 <code>MOV [1234H], CX</code> <code>MOV CL, [1234H]</code></li>
<li>直接寻址方式下，操作数的段地址默认为数据段<ul>
<li>但允许段重设，即由指令定义段，说明数据存放在其他逻辑段中</li>
<li><code>MOV  AX, ES:[1200H]</code> 指令将 <code>ES:[1200H]</code> 的数存入 <code>AX</code></li>
<li>这种情况称为段超越，所加的段寄存器叫段前缀</li>
</ul>
</li>
</ul>
<h4 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h4><p>偏移地址 = 寄存器值</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/4a158b764ea4be17e2ce448671ea8b29a4fcf7f42685e7e20c2466b98e9c7bab.png" alt="寄存器间接寻址" title>
                </div>
                <div class="image-caption">寄存器间接寻址</div>
            </figure>  


<ul>
<li>“偏移地址”只能来自于间址寄存器(BX, BP, SI, DI)<ul>
<li>间址寄存器必须为 16-bit registers</li>
</ul>
</li>
<li>“段地址”取决于基址寄存器<ul>
<li>BX, SI, DI -&gt; DS</li>
<li>BP -&gt; SS</li>
<li>但允许段超越</li>
</ul>
</li>
</ul>
<h4 id="寄存器相对寻址"><a href="#寄存器相对寻址" class="headerlink" title="寄存器相对寻址"></a>寄存器相对寻址</h4><p>偏移地址 = 寄存器值 + 立即数</p>
<ul>
<li>寄存器值同样来自于 BX、BP、SI 或 DI</li>
</ul>
<h4 id="基址-变址寻址"><a href="#基址-变址寻址" class="headerlink" title="基址-变址寻址"></a>基址-变址寻址</h4><p>偏移地址 = 基址寄存器值 + 变址寄存器值</p>
<ul>
<li>“段地址”取决于基址寄存器<ul>
<li>BX -&gt; DS</li>
<li><strong>BP -&gt; SS</strong>（在计算题中，不要无脑使用 <code>DS</code> 作段地址！！！BP 需要使用 SS）</li>
</ul>
</li>
<li>常用于一维数组</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/81f301c50d50d3cab2d8782fbef2224215544487edc8c2f1a6b1ba875d45eef0.png" alt="例" title>
                </div>
                <div class="image-caption">例</div>
            </figure>  


<h4 id="基址-变址-相对寻址"><a href="#基址-变址-相对寻址" class="headerlink" title="基址-变址-相对寻址"></a>基址-变址-相对寻址</h4><p>偏移地址 = 基址寄存器值 + 变址寄存器值 + 立即数</p>
<ul>
<li>段地址同上</li>
<li>常用于二维数组</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/50517c34007f40bc1e32bd967274f7cae5a7056bc92b41a514d7ae2edecea51e.png" alt="例" title>
                </div>
                <div class="image-caption">例</div>
            </figure>  

<h4 id="五种寻址方式的总结"><a href="#五种寻址方式的总结" class="headerlink" title="五种寻址方式的总结"></a>五种寻址方式的总结</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/9495b586ce3ba38f7e4915566d352552ccdb4f13299c0f77c495008bc6e56b58.png" alt="五种寻址方式的总结" title>
                </div>
                <div class="image-caption">五种寻址方式的总结</div>
            </figure>  

<p>除立即寻址、寄存器寻址、隐含寻址外，其余都是计算得到偏移地址，然后在 <strong>BIU 中的地址加法器</strong>运算（<code>+16*基地址</code>）得到物理地址。</p>
<h4 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h4><p>指令中隐含了一个或两个操作数的地址，即操作数在默认的地址中。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MUL</span> <span class="built_in">BL</span></span><br><span class="line"><span class="comment">; AX = AL * BL</span></span><br></pre></td></tr></table></figure>

<h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><h4 id="通用数据传送"><a href="#通用数据传送" class="headerlink" title="通用数据传送"></a>通用数据传送</h4><p><strong>该类指令的执行对标志位不产生影响</strong></p>
<h5 id="一般数据传送指令-MOV"><a href="#一般数据传送指令-MOV" class="headerlink" title="一般数据传送指令 MOV"></a>一般数据传送指令 MOV</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> dest, src</span><br><span class="line"><span class="comment">; 读取 src 并保存到 dest</span></span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>FLAGS 寄存器一般不作为操作数在指令中出现</li>
<li>两操作数长度必须相同</li>
<li>（下面的知识建议用下图代替）</li>
<li>存储单元之间不能直接传送</li>
<li>段寄存器 CS 只能作源操作数</li>
<li>段寄存器之间不能直接传送</li>
<li>在源操作数是立即数时，目标操作数不能是段寄存器（必须经通用寄存器中转）</li>
</ul>
<p><img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/19dd0bb079591ffd2724c014246374d23fbad8fd1a3863a1d2d895ca61b35062.png" alt="MOV指令的传送方向示意图">  </p>
<p>例题：判断下列指令的正确性：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span>  <span class="built_in">AL</span>, <span class="built_in">BX</span>             <span class="comment">; 错误，长度不一致</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">AX</span>, [<span class="built_in">SI</span>]<span class="number">05H</span>        <span class="comment">; 对</span></span><br><span class="line"><span class="keyword">MOV</span>  [<span class="built_in">BX</span>][<span class="built_in">BP</span>], <span class="built_in">AX</span>       <span class="comment">; 错误，同时使用两个基址寄存器</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">DS</span>, <span class="number">1000H</span>          <span class="comment">; 错误，常数不能直接送段寄存器</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">DX</span>, <span class="number">09H</span>            <span class="comment">; 对</span></span><br><span class="line"><span class="keyword">MOV</span>  [<span class="number">1200H</span>], [<span class="built_in">SI</span>]      <span class="comment">; 错误，dst 和 src 不能同时为存储器</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">AX</span>, <span class="built_in">CS</span>             <span class="comment">; 对</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">DS</span>, <span class="built_in">CS</span>             <span class="comment">; 错误，段寄存器之间不能传送</span></span><br></pre></td></tr></table></figure>

<p>例：将符号“*”的ASCII码2AH送入内存数据段中以变址指针DI所指的单元再偏移100个字节单元中：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">AL</span>, <span class="string">'*'</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="number">100</span>[<span class="built_in">DI</span>], <span class="built_in">AL</span></span><br></pre></td></tr></table></figure>

<h5 id="堆栈操作指令-PUSH-POP"><a href="#堆栈操作指令-PUSH-POP" class="headerlink" title="堆栈操作指令 PUSH POP"></a>堆栈操作指令 PUSH POP</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PUSH</span> OPRD</span><br><span class="line"><span class="comment">; 压栈</span></span><br><span class="line"><span class="keyword">POP</span> OPRD</span><br><span class="line"><span class="comment">; 出栈</span></span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>堆栈操作以字为单位，故操作数必为 16 位</li>
<li>操作数不能是立即数</li>
<li>操作数可以来自寄存器或存储器<ul>
<li>若为存储器操作数，需要声明为字存储单元</li>
</ul>
</li>
<li>不能 POP 到 CS</li>
<li>PUSH 顺序是从高地址向低地址</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/4cdfa19a2e508875f011987428fe17c8a5942632dc0454993f043e233e66c906.png" alt="压栈过程" title>
                </div>
                <div class="image-caption">压栈过程</div>
            </figure>  

<p><img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/3e47c7ad9897cd201bca3cb98b632a54d0726fed5bf6e84033770d34eaeb9f3d.png" alt="出栈过程">  </p>
<h5 id="交换指令-XCHG"><a href="#交换指令-XCHG" class="headerlink" title="交换指令 XCHG"></a>交换指令 XCHG</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; XCHG REG/MEM, REG/MEM</span></span><br><span class="line"><span class="keyword">XCHG</span>	<span class="built_in">AX</span>, <span class="built_in">BX</span></span><br><span class="line"><span class="keyword">XCHG</span>	[<span class="number">2000</span>], <span class="built_in">CL</span></span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>两操作数至少有一个是寄存器操作数</li>
<li>不允许使用段寄存器</li>
</ul>
<h5 id="字位扩展指令-CBW-CWD"><a href="#字位扩展指令-CBW-CWD" class="headerlink" title="字位扩展指令 CBW CWD"></a>字位扩展指令 CBW CWD</h5><ul>
<li>将带符号数的符号位 (0/1) 扩展到高位；</li>
<li>零操作数指令，采用隐含寻址，隐含的操作数为 AX 或者 “AX与DX”</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CBW</span></span><br><span class="line"><span class="comment">; 将 AL 的符号位扩展到 AH (Convert Byte to Word)</span></span><br><span class="line"><span class="comment">; 若 AL 最高位=1，则执行后 AH = FFH</span></span><br><span class="line"><span class="comment">; 若 AL 最高位=0，则执行后 AH = 00H</span></span><br></pre></td></tr></table></figure>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CWD</span></span><br><span class="line"><span class="comment">; 将 AX 符号位扩展到 DX (Convert Word to Double)</span></span><br><span class="line"><span class="comment">; 若 AX 最高位=1，则执行后 DX = FFFFH</span></span><br><span class="line"><span class="comment">; 若 AX 最高位=0，则执行后 DX = 0000H</span></span><br></pre></td></tr></table></figure>

<p>判断以下指令执行结果：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">AL</span>, <span class="number">44H</span></span><br><span class="line"><span class="keyword">CBW</span></span><br><span class="line"><span class="comment">; AX = 0044H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">AX</span>, <span class="number">0AFDEH</span></span><br><span class="line"><span class="keyword">CWD</span></span><br><span class="line"><span class="comment">; DX = 0000H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">AL</span>，<span class="number">86H</span></span><br><span class="line"><span class="keyword">CBW</span></span><br><span class="line"><span class="comment">; AX = FF86H</span></span><br></pre></td></tr></table></figure>

<h4 id="输入输出指令-IN-OUT"><a href="#输入输出指令-IN-OUT" class="headerlink" title="输入输出指令 IN OUT"></a>输入输出指令 IN OUT</h4><ul>
<li>专门面向I/O端口操作的指令</li>
<li>输入指令：<code>IN acc, PORT</code></li>
<li>输出指令：<code>OUT PORT, acc</code></li>
<li><code>PORT</code> 为端口地址，<code>acc</code> 为累加寄存器 AL 或 AX</li>
</ul>
<p><code>PORT</code> 的寻址方式：</p>
<ul>
<li>直接寻址<ul>
<li>端口地址为 8 位时，指令中直接给出 8 位端口地址</li>
<li>可寻址 256 个端口</li>
</ul>
</li>
<li>间接寻址<ul>
<li>端口地址为 16 位时，指令中的端口地址必须由 DX 指定</li>
<li>可寻址 64K 个端口</li>
</ul>
</li>
</ul>
<p>例：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">IN</span> <span class="built_in">AX</span>, <span class="number">80H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">DX</span>, <span class="number">2400H</span></span><br><span class="line"><span class="keyword">IN</span> <span class="built_in">AL</span>, <span class="built_in">DX</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">OUT</span> <span class="number">35H</span>, <span class="built_in">AX</span></span><br></pre></td></tr></table></figure>

<h4 id="地址传送指令-LEA-LDS-LES"><a href="#地址传送指令-LEA-LDS-LES" class="headerlink" title="地址传送指令 LEA LDS LES"></a>地址传送指令 LEA LDS LES</h4><h5 id="取偏移地址指令-LEA"><a href="#取偏移地址指令-LEA" class="headerlink" title="取偏移地址指令 LEA"></a>取偏移地址指令 LEA</h5><p>LEA (Load Effective Address)：将一个存储单元的 16 位偏移地址取出送 16 位通用寄存器（常为间址寄存器）。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LEA</span> REG, MEM</span><br></pre></td></tr></table></figure>

<p>类似于 <code>MOV</code>，但 <code>MOV</code> 取的是存储器值，而 <code>LEA</code> 取的是存储器的偏移地址。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/8fe69e6b5caee4cf1b7ed605fa1c7c1173a0d5ab42f9bf0526e616fa68d19ee9.png" alt="MOV 和 LEA 对比" title>
                </div>
                <div class="image-caption">MOV 和 LEA 对比</div>
            </figure>  

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">SI</span>, DATA1</span><br><span class="line"><span class="comment">; 这里的 DATA1 是符号地址</span></span><br><span class="line"><span class="comment">; SI = [DATA1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LEA</span> <span class="built_in">SI</span>, DATA1</span><br><span class="line"><span class="comment">; SI = DATA1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">BX</span>, [<span class="built_in">BX</span>]</span><br><span class="line"><span class="comment">; BX = BX 作为偏移地址对应的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LEA</span> <span class="built_in">BX</span>, [<span class="built_in">BX</span>]</span><br><span class="line"><span class="comment">; BX 不变</span></span><br></pre></td></tr></table></figure>

<p>看起来 <code>LEA</code> 有点蠢，但其是有存在意义的：当寻址方式比较复杂（如<a href="#基址-变址-相对寻址">基址-变址-相对寻址</a>），<code>LEA</code> 能一行获取其地址，但 <code>MOV</code> 指令则不行，因为 <code>MOV</code> 不支持加法。详见<a href="https://stackoverflow.com/questions/1658294/whats-the-purpose-of-the-lea-instruction" target="_blank" rel="noopener">What’s the purpose of the LEA instruction? - Stack Overflow</a>。</p>
<p>一道简单的例题：将数据段中首地址为 MEM1 的 50 字节的数据传送到同一逻辑段首地址为 MEM2 的区域存放。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/d28ed269b600f75c3d3596cf6fd508f4d27b6668606c7e3ca96cbdec4290ecd3.png" alt="流程图" title>
                </div>
                <div class="image-caption">流程图</div>
            </figure>  

<p>代码如下：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">LEA</span> <span class="built_in">SI</span>, MEM1</span><br><span class="line">      <span class="keyword">LEA</span> <span class="built_in">DI</span>, MEM2 </span><br><span class="line">      <span class="keyword">MOV</span> <span class="built_in">CL</span>, <span class="number">50</span></span><br><span class="line"><span class="symbol">NEXT:</span> <span class="keyword">MOV</span> <span class="built_in">AL</span>, [<span class="built_in">SI</span>]</span><br><span class="line">      <span class="keyword">MOV</span> [<span class="built_in">DI</span>], <span class="built_in">AL</span></span><br><span class="line">      <span class="keyword">INC</span> <span class="built_in">SI</span></span><br><span class="line">      <span class="keyword">INC</span> <span class="built_in">DI</span></span><br><span class="line">      <span class="keyword">DEC</span> <span class="built_in">CL</span> </span><br><span class="line">      <span class="keyword">JNZ</span> NEXT</span><br><span class="line">      <span class="keyword">HLT</span>           <span class="comment">; halt，暂停执行</span></span><br></pre></td></tr></table></figure>

<p>眼睛：我没学会<br>脑子：我也没学会</p>
<p>LEA 不访问存储器，而下面的 LDS、LES 要访问存储器。</p>
<h5 id="装入地址指针指令-LDS-LES"><a href="#装入地址指针指令-LDS-LES" class="headerlink" title="装入地址指针指令 LDS LES"></a>装入地址指针指令 LDS LES</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LDS</span> DEST, SRC</span><br><span class="line"><span class="keyword">LES</span> DEST, SRC</span><br></pre></td></tr></table></figure>

<ul>
<li>把 SRC 存储单元开始的 4 个字节单元的内容（低 16 位）送入 DEST 通用寄存器和（高 16 位）段寄存器 DS（LDS指令）或 ES（LES指令）</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/ffe42aec65bbfba62190672930bf7d56bc382215b41cbbd5cd4b2e2d22ea5c62.png" alt="例题" title>
                </div>
                <div class="image-caption">例题</div>
            </figure>

<p>执行后，<code>SI=0020H</code>，<code>DS=5030H</code>。</p>
<h4 id="标志位操作指令"><a href="#标志位操作指令" class="headerlink" title="标志位操作指令"></a>标志位操作指令</h4><h5 id="LAHF-SAHF"><a href="#LAHF-SAHF" class="headerlink" title="LAHF SAHF"></a>LAHF SAHF</h5><ul>
<li>LAHF (Load Flags to AH)：将 FLAGS 的低 8 位装入 AH</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/b5c6d77b0f09db79bc86f1f25cb8cb26b0528094b205b42684cc7b04bbe67b2a.png" alt="LAHF" title>
                </div>
                <div class="image-caption">LAHF</div>
            </figure>  

<ul>
<li>SAHF (Save Flags to AH)：执行与LAHF相反的操作</li>
</ul>
<h5 id="PUSHF-POPF"><a href="#PUSHF-POPF" class="headerlink" title="PUSHF POPF"></a>PUSHF POPF</h5><ul>
<li>PUSHF：将 FLAGS 压栈</li>
<li>POPF：将栈顶弹出给 FLAGS</li>
</ul>
<h3 id="算术运算类指令"><a href="#算术运算类指令" class="headerlink" title="算术运算类指令"></a>算术运算类指令</h3><p>这类指令的执行大多对状态标志位会产生影响。</p>
<h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><h5 id="带符号加法-ADD"><a href="#带符号加法-ADD" class="headerlink" title="带符号加法 ADD"></a>带符号加法 ADD</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span> OPRD1, OPRD2</span><br><span class="line"><span class="comment">; OPRD1 = OPRD1 + OPRD2</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>ADD</code> 指令的执行对全部 6 个状态标志位都产生影响</li>
</ul>
<p>例：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">AL</span>, <span class="number">78H</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="built_in">AL</span>, <span class="number">99H</span></span><br><span class="line"><span class="comment">; 试写出指令执行后的结果</span></span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/d9203225ce9f68a97b811f0b7a0036e74a9aa84c55827106925f29e9ffe02b03.png" alt="结果及标志位" title>
                </div>
                <div class="image-caption">结果及标志位</div>
            </figure>  

<h5 id="带进位加法-ADC"><a href="#带进位加法-ADC" class="headerlink" title="带进位加法 ADC"></a>带进位加法 ADC</h5><p>ADC (ADd with Carry) 可用于实现多字节数（大数）相加。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADC</span> OPRD1, OPRD2</span><br><span class="line"><span class="comment">; OPRD1 = CF + OPRD1 + OPRD2</span></span><br></pre></td></tr></table></figure>

<p>例：求两个大数的和，两个数的长度为 20 字节，首地址为 <code>M1</code> 和 <code>M2</code>。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">LEA</span> <span class="built_in">SI</span>, M1</span><br><span class="line">      <span class="keyword">LEA</span> <span class="built_in">DI</span>, M2</span><br><span class="line">      <span class="keyword">MOV</span> <span class="built_in">CX</span>, <span class="number">20</span></span><br><span class="line">      <span class="keyword">CLC</span>           <span class="comment">; 使CF=0</span></span><br><span class="line"><span class="symbol">NEXT:</span> <span class="keyword">MOV</span> <span class="built_in">AL</span>, [<span class="built_in">SI</span>]</span><br><span class="line">      <span class="keyword">ADC</span> [<span class="built_in">DI</span>], <span class="built_in">AL</span></span><br><span class="line">      <span class="keyword">INC</span> <span class="built_in">SI</span>        <span class="comment">; SI、DI 自增</span></span><br><span class="line">      <span class="keyword">INC</span> <span class="built_in">DI</span></span><br><span class="line">      <span class="keyword">DEC</span> <span class="built_in">CX</span>        <span class="comment">; CX 自减</span></span><br><span class="line">      <span class="keyword">JNZ</span> NEXT      <span class="comment">; Jump if（当运算结果） Not Zero</span></span><br><span class="line">      <span class="keyword">HLT</span></span><br></pre></td></tr></table></figure>

<h5 id="自增-INC"><a href="#自增-INC" class="headerlink" title="自增 INC"></a>自增 INC</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INC</span> OPRD</span><br><span class="line"><span class="comment">; OPRD = OPRD + 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>OPRD</code> 不能是段寄存器或立即数</li>
<li><code>INC</code> 指令执行不影响 <code>CF</code> 标志，只影响其他五个</li>
</ul>
<h4 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h4><h5 id="带符号减法-SUB"><a href="#带符号减法-SUB" class="headerlink" title="带符号减法 SUB"></a>带符号减法 SUB</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SUB</span> OPRD1, OPRD2</span><br><span class="line"><span class="comment">; OPRD1 = OPRD1 - OPRD2</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>SUB</code> 指令的执行对全部 6 个状态标志位都产生影响（同 <code>ADD</code>）</li>
</ul>
<h5 id="带借位减法-SBB"><a href="#带借位减法-SBB" class="headerlink" title="带借位减法 SBB"></a>带借位减法 SBB</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SBB</span> OPRD1, OPRD2</span><br><span class="line"><span class="comment">; OPRD1 = OPRD1 - OPRD2 - CF</span></span><br></pre></td></tr></table></figure>

<p>SBB (SuBtraction with Borrow)：指令格式、对操作数的要求、对标志位的影响与 <code>SUB</code> 指令完全一样</p>
<h5 id="自减-DEC"><a href="#自减-DEC" class="headerlink" title="自减 DEC"></a>自减 DEC</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DEC</span> OPRD</span><br><span class="line"><span class="comment">; OPRD = OPRD-1</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>OPRD</code> 不能是段寄存器或立即数</li>
<li><code>DEC</code> 不影响 <code>CF</code></li>
</ul>
<p>例 1：实现一个计数循环程序</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">MOV</span> <span class="built_in">AL</span>, <span class="number">10H</span></span><br><span class="line"><span class="symbol">LOP:</span> <span class="keyword">DEC</span> <span class="built_in">AL</span></span><br><span class="line">     <span class="keyword">JNC</span> LOP <span class="comment">; Jump if Not CF</span></span><br><span class="line"><span class="comment">; 错误！ DEC 不影响 CF</span></span><br><span class="line"><span class="comment">; 程序会执行一次后停止（原 CF = 1）</span></span><br><span class="line"><span class="comment">; 或死循环 （原 CF = 0）</span></span><br></pre></td></tr></table></figure>

<p>例 2 是一个两层的嵌套循环：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       <span class="keyword">MOV</span> <span class="built_in">BL</span>, <span class="number">2</span></span><br><span class="line"><span class="symbol">NEXT1:</span> <span class="keyword">MOV</span> <span class="built_in">CX</span>, <span class="number">0FFFFH</span></span><br><span class="line"><span class="symbol">NEXT2:</span> <span class="keyword">DEC</span> <span class="built_in">CX</span></span><br><span class="line">       <span class="keyword">JNZ</span> NEXT2</span><br><span class="line">       <span class="keyword">DEC</span> <span class="built_in">BL</span></span><br><span class="line">       <span class="keyword">JNZ</span> NEXT1</span><br><span class="line">       <span class="keyword">HLT</span></span><br></pre></td></tr></table></figure>

<h5 id="求补-NEG"><a href="#求补-NEG" class="headerlink" title="求补 NEG"></a>求补 NEG</h5><ul>
<li>NEG 将影响六个标志位<ul>
<li>当且仅当操作数为 0 时，CF = 0</li>
<li>当且仅当字节操作数为 -128 (80H) 或字操作数为 -32768 (8000H) 时，OF = 1</li>
</ul>
</li>
</ul>
<h5 id="比较-CMP"><a href="#比较-CMP" class="headerlink" title="比较 CMP"></a>比较 CMP</h5><p>只影响六个标志位，不会存储结果。可以接 <code>JNZ</code> <code>JNC</code> 等语句实现条件跳转。</p>
<p>两个数大小比较：</p>
<table>
<thead>
<tr>
<th><code>CMP AX, BX</code></th>
<th>无符号数</th>
<th>有符号数</th>
</tr>
</thead>
<tbody><tr>
<td><code>AX=BX</code></td>
<td><code>ZF=0</code></td>
<td><code>ZF=0</code></td>
</tr>
<tr>
<td><code>AX&gt;BX</code></td>
<td><code>CF=0, ZF=0</code></td>
<td><code>OF=SF, ZF=0</code></td>
</tr>
<tr>
<td><code>AX&lt;BX</code></td>
<td><code>CF=1, ZF=0</code></td>
<td><code>OF!=SF, ZF=0</code></td>
</tr>
<tr>
<td>可相关判断指令</td>
<td><code>JA</code> <code>JAE</code> <code>JB</code> <code>JBE</code></td>
<td><code>JG</code> <code>JGE</code> <code>JL</code> <code>JLE</code></td>
</tr>
</tbody></table>
<p>例题：在 20 个无符号数中找出最大的数，并将其存放在 MAX 单元中。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">LEA</span> <span class="built_in">BX</span>, MAX</span><br><span class="line">      <span class="keyword">LEA</span> <span class="built_in">SI</span>, BUF</span><br><span class="line">      <span class="keyword">MOV</span> <span class="built_in">CL</span>, <span class="number">20</span></span><br><span class="line">      <span class="keyword">MOV</span> <span class="built_in">AL</span>, [<span class="built_in">SI</span>]   <span class="comment">; AL 保存目前的最大值</span></span><br><span class="line"><span class="symbol">NEXT:</span> <span class="keyword">INC</span> <span class="built_in">SI</span></span><br><span class="line">      <span class="keyword">CMP</span> <span class="built_in">Al</span>, [<span class="built_in">SI</span>]</span><br><span class="line">      <span class="keyword">JNC</span> GOON       <span class="comment">; CF=0 转移</span></span><br><span class="line">      <span class="keyword">MOV</span> <span class="built_in">AL</span>, [<span class="built_in">SI</span>]   <span class="comment">; 将更大的 [SI] 放进 AL</span></span><br><span class="line"><span class="symbol">GOON:</span> <span class="keyword">DEC</span> <span class="built_in">CL</span></span><br><span class="line">      <span class="keyword">JNZ</span> NEXT</span><br><span class="line">      <span class="keyword">MOV</span> [<span class="built_in">BX</span>], <span class="built_in">AL</span></span><br><span class="line">      <span class="keyword">HLT</span></span><br></pre></td></tr></table></figure>

<h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><ul>
<li>运算结果长度是乘数的两倍，即 <code>8位-&gt;16位</code>，<code>16位-&gt;32位</code></li>
<li>隐含寻址，隐含的是存放被乘数的累加寄存器 <code>AL</code> 或 <code>AX</code> 及存放结果的 <code>AX</code>，<code>DX</code></li>
<li>乘法只影响 <code>OF</code>、<code>CF</code>；若运算结果的高半部分是无效数值，则 <code>OF=CF=0</code>，否则 <code>OF=CF=1</code><ul>
<li>即考虑了 8 位乘 8 位，若 <code>OF=CF=0</code>，结果仍可以用 8 位的情况<ul>
<li>对于无符号乘法，当且仅当高半部分为全 0， <code>OF=CF=1</code></li>
<li>对于有符号乘法，当且仅当高半部分为低半部分的符号扩展，<code>OF=CF=1</code></li>
</ul>
</li>
<li>若有符号乘法结果为 <code>00000000 11111111</code>，高半部分不是符号扩展，<code>CF=OF=0</code>：若在后续步骤只看后半部分，会导致原来的正值被（错误地）识别为负值</li>
</ul>
</li>
</ul>
<h5 id="无符号乘法-MUL"><a href="#无符号乘法-MUL" class="headerlink" title="无符号乘法 MUL"></a>无符号乘法 MUL</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MUL</span> OPRD</span><br><span class="line"><span class="comment">; 字节运算：AX = AL * OPRD</span></span><br><span class="line"><span class="comment">; 字运算：  DX:AX = AX * OPRD</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>OPRD</code> 不能是立即数</li>
<li>若结果高半部（<code>AH</code> 或 <code>DX</code>）是全 0（不是有效数值），则 <code>CF</code>=<code>OF</code>=0，否则 <code>CF</code>=<code>OF</code>=1</li>
</ul>
<h5 id="带符号乘法-IMUL"><a href="#带符号乘法-IMUL" class="headerlink" title="带符号乘法 IMUL"></a>带符号乘法 IMUL</h5><p><code>IMUL</code> (sIgned MULtiply) 除了操作数是带符号外，其余与 <code>MUL</code> 指令相同。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">IMUL</span> OPRD</span><br></pre></td></tr></table></figure>

<ul>
<li>若结果高半部（<code>AH</code> 或 <code>DX</code>）是低半部的符号扩展（不是有效数值），则 <code>CF</code>=<code>OF</code>=0，否则 <code>CF</code>=<code>OF</code>=1<ul>
<li>需要注意，若 <code>AH</code>=11111111，<code>AL</code> 最高位为 0（不是符号扩展），则 CF=OF=0</li>
</ul>
</li>
</ul>
<h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 无符号除法</span></span><br><span class="line"><span class="keyword">DIV</span> OPRD</span><br><span class="line"></span><br><span class="line"><span class="comment">; 有符号除法</span></span><br><span class="line"><span class="keyword">IDIV</span> OPRD</span><br></pre></td></tr></table></figure>

<ul>
<li>指令要求被除数是除数的双倍字长</li>
<li>若 <code>OPRD</code> 是 8 bits<ul>
<li>执行：<code>AX/OPRD</code></li>
<li><code>AL</code> = 商</li>
<li><code>AH</code> = 余数</li>
</ul>
</li>
<li>若 <code>OPRD</code> 是 16 bits<ul>
<li>执行：<code>DX:AX/OPRD</code></li>
<li><code>AX</code> = 商</li>
<li><code>DX</code> = 余数</li>
</ul>
</li>
</ul>
<p>除法指令常和 <code>CBW</code> 或 <code>CWD</code> 配合使用。</p>
<h4 id="BCD-码调整指令"><a href="#BCD-码调整指令" class="headerlink" title="BCD 码调整指令"></a>BCD 码调整指令</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/6939376970e09f4138063eaf1684ec0cbc84518c32bc2a5ddd5887720210c590.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>  
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/f07b55addce64725145a23c41700eebda4947fd3721354d4acc6add68c3dd409.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>  
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/1adbd5c08e7d6d1bda5ecb588ec10f9b5336c76828a436559717805bc257daa2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>  
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/" alt="94be973a6bca8a5c4e9684c58647f5c8fcd2fedd3c59edb4e74313467885cc6a.png" title>
                </div>
                <div class="image-caption">94be973a6bca8a5c4e9684c58647f5c8fcd2fedd3c59edb4e74313467885cc6a.png</div>
            </figure>  

<h3 id="逻辑运算和移位指令"><a href="#逻辑运算和移位指令" class="headerlink" title="逻辑运算和移位指令"></a>逻辑运算和移位指令</h3><h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><ul>
<li>逻辑运算指令对操作数的要求大多与MOV指令相同</li>
<li>“非”运算指令要求操作数不能是立即数</li>
<li>除“非”运算指令外，其余指令的执行都会使标志位 <code>OF</code> = <code>CF</code> = 0</li>
</ul>
<h5 id="与-AND"><a href="#与-AND" class="headerlink" title="与 AND"></a>与 AND</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">AND</span>  OPRD1, OPRD2</span><br><span class="line"><span class="comment">; 两操作数按位相“与”，结果送目标地址 OPRD1</span></span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 实现两操作数按位相与的运算</span></span><br><span class="line"><span class="keyword">AND</span>  <span class="built_in">BL</span>, [<span class="built_in">SI</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">; 使目标操作数的某些位不变，某些位清零</span></span><br><span class="line"><span class="keyword">AND</span>  <span class="built_in">AL</span>, <span class="number">0FH</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 在操作数不变的 情况下使 CF 和 OF 清零</span></span><br><span class="line"><span class="keyword">AND</span>  <span class="built_in">AX</span>, <span class="built_in">AX</span></span><br></pre></td></tr></table></figure>

<p>例 2：从地址为 <code>3F8H</code> 端口中读入一个字节数，如果该数 bit1 位为 1，则将 <code>DATA</code> 为首地址的一个字输出到 <code>38FH</code> 端口，否则就不能进行数据传送。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">LEA</span> <span class="built_in">SI</span>, DATA</span><br><span class="line">      <span class="keyword">MOV</span> <span class="built_in">DX</span>, <span class="number">3F8H</span></span><br><span class="line"><span class="symbol">WAIT:</span> <span class="keyword">IN</span> <span class="built_in">AL</span>, <span class="built_in">DX</span></span><br><span class="line">      <span class="keyword">AND</span> <span class="built_in">AL</span>, <span class="number">02H</span></span><br><span class="line">      <span class="keyword">JZ</span> WAIT       <span class="comment">; ZF=1转移</span></span><br><span class="line">      <span class="keyword">MOV</span> <span class="built_in">DX</span>, <span class="number">38FH</span></span><br><span class="line">      <span class="keyword">MOV</span> <span class="built_in">AX</span>, [<span class="built_in">SI</span>]</span><br><span class="line">      <span class="keyword">OUT</span> <span class="built_in">DX</span>, <span class="built_in">AX</span></span><br></pre></td></tr></table></figure>

<h5 id="或-OR"><a href="#或-OR" class="headerlink" title="或 OR"></a>或 OR</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OR</span> OPRD1, OPRD2</span><br><span class="line"><span class="comment">; 两操作数按位相“或”，结果送目标地址 OPRD1</span></span><br></pre></td></tr></table></figure>

<p>例题：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 实现两操作数 相“或”的运算</span></span><br><span class="line"><span class="keyword">OR</span> <span class="built_in">AX</span>, [<span class="built_in">DI</span>]</span><br><span class="line"><span class="comment">; 使某些位不变，某些位置“1”</span></span><br><span class="line"><span class="keyword">OR</span> <span class="built_in">CL</span>, <span class="number">0FH</span></span><br><span class="line"><span class="comment">; 在不改变操作数的情况下使 OF=CF=0</span></span><br><span class="line"><span class="keyword">OR</span> <span class="built_in">AX</span>, <span class="built_in">AX</span></span><br></pre></td></tr></table></figure>

<h5 id="非-NOT"><a href="#非-NOT" class="headerlink" title="非 NOT"></a>非 NOT</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">NOT</span> OPRD</span><br><span class="line"><span class="comment">; 操作数按位取反再送回原地址</span></span><br></pre></td></tr></table></figure>

<ul>
<li>操作数不能是立即数</li>
<li>对标志位无影响<br>例：</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">NOT</span> <span class="built_in">BYTE</span> <span class="built_in">PTR</span>[<span class="built_in">BX</span>]</span><br></pre></td></tr></table></figure>

<p>这里的 <code>BYTE PTR</code> 是强制转换，见<a href="#ptr-运算符">PTR 运算符</a>。</p>
<h5 id="异或-XOR"><a href="#异或-XOR" class="headerlink" title="异或 XOR"></a>异或 XOR</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">XOR</span> OPRD1, OPRD2</span><br><span class="line"><span class="comment">; 两操作数按位相“异或”，结果送目标地址 OPRD1</span></span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">XOR</span> <span class="built_in">BL</span>, <span class="number">80H</span>  <span class="comment">; 将 BL 的最高位变反</span></span><br><span class="line"><span class="keyword">XOR</span> <span class="built_in">AX</span>, <span class="built_in">AX</span>   <span class="comment">; 将 AX 清零</span></span><br></pre></td></tr></table></figure>

<p>注意，<code>XOR AX, AX</code> 的效果等价于 <code>MOV AX, 0</code>，但：</p>
<ul>
<li>前者会使 <code>OF</code>=<code>CF</code>=0</li>
<li>前者的字节码更短</li>
<li>前者在旧的架构上速度会更快</li>
<li>参见 <a href="https://stackoverflow.com/questions/26645676/xor-ax-ax-when-loading-segment-register" target="_blank" rel="noopener">xor ax, ax when loading segment register - Stack Overflow</a></li>
</ul>
<h5 id="测试（与）-TEST"><a href="#测试（与）-TEST" class="headerlink" title="测试（与） TEST"></a>测试（与） TEST</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TEST</span> OPRD1, OPRD2</span><br><span class="line"><span class="comment">; 执行“与”运算，运算的结果影响标志位，但不送回目标地址</span></span><br><span class="line"><span class="comment">; 常用于测试某些位的状态</span></span><br></pre></td></tr></table></figure>

<p>例题：从地址为 <code>3F8H</code> 的端口中读入一个字节数，当该数的 bit1， bit3， bit5 位同时为 1 时，则从 <code>38FH</code> 端口将 DATA 为首地址的一个字输出，否则就从端口重新输入。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">LEA</span>  <span class="built_in">SI</span>, DATA</span><br><span class="line">      <span class="keyword">MOV</span>  <span class="built_in">DX</span>, <span class="number">3F8H</span></span><br><span class="line"><span class="symbol">WAIT:</span> <span class="keyword">IN</span>  <span class="built_in">AL</span>, <span class="built_in">DX</span></span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line">      <span class="keyword">MOV</span>  <span class="built_in">DX</span>, <span class="number">38FH</span></span><br><span class="line">      <span class="keyword">MOV</span>  <span class="built_in">AX</span>, [<span class="built_in">SI</span>]</span><br><span class="line">      <span class="keyword">OUT</span>  <span class="built_in">DX</span>, <span class="built_in">AX</span></span><br></pre></td></tr></table></figure>

<p><code>; ...</code> 部分的代码可以有三个版本：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TEST</span> <span class="built_in">AL</span>, <span class="number">02H</span></span><br><span class="line"><span class="keyword">JZ</span> WAIT       <span class="comment">; ZF=1转移</span></span><br><span class="line"><span class="keyword">TEST</span> <span class="built_in">AL</span>, <span class="number">08H</span></span><br><span class="line"><span class="keyword">JZ</span> WAIT</span><br><span class="line"><span class="keyword">TEST</span> <span class="built_in">AL</span>, <span class="number">20H</span></span><br><span class="line"><span class="keyword">JZ</span> WAIT</span><br></pre></td></tr></table></figure>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">AND</span> <span class="built_in">AL</span>, <span class="number">2AH</span></span><br><span class="line"><span class="keyword">CMP</span> <span class="built_in">AL</span>, <span class="number">2AH</span></span><br><span class="line"><span class="keyword">JNZ</span> WAIT</span><br></pre></td></tr></table></figure>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">AND</span> <span class="built_in">AL</span>, <span class="number">2AH</span></span><br><span class="line"><span class="keyword">XOR</span> <span class="built_in">AL</span>, <span class="number">2AH</span></span><br><span class="line"><span class="keyword">JNZ</span> WAIT</span><br></pre></td></tr></table></figure>

<h4 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h4><h5 id="算术左移-SAL-逻辑左移-SHL"><a href="#算术左移-SAL-逻辑左移-SHL" class="headerlink" title="算术左移 SAL 逻辑左移 SHL"></a>算术左移 SAL 逻辑左移 SHL</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 算术左移 (Shift Arithmetic Left) 指令，视为有符号数</span></span><br><span class="line"><span class="keyword">SAL</span> OPRD, <span class="number">1</span></span><br><span class="line"><span class="keyword">SAL</span> OPRD, <span class="built_in">CL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 逻辑左移指令，视为无符号数</span></span><br><span class="line"><span class="keyword">SHL</span> OPRD, <span class="number">1</span></span><br><span class="line"><span class="keyword">SHL</span> OPRD, <span class="built_in">CL</span></span><br></pre></td></tr></table></figure>

<p><code>CL</code> 是 <code>CX</code> 寄存器的低 8 位。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/5d244f81043fbffb79a752c98e4480efa41ab9585c8cd0e27c0e7f3fe3e7ca20.png" alt="SAL 和 SHL" title>
                </div>
                <div class="image-caption">SAL 和 SHL</div>
            </figure>  

<p>二者实际上就是一条指令，都是最低位补 0，最高位移到 <code>CF</code>。</p>
<h5 id="算术右移-SAR-逻辑右移-SHR"><a href="#算术右移-SAR-逻辑右移-SHR" class="headerlink" title="算术右移 SAR 逻辑右移 SHR"></a>算术右移 SAR 逻辑右移 SHR</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 算术右移指令，视为有符号数</span></span><br><span class="line"><span class="keyword">SAR</span> OPRD, <span class="number">1</span></span><br><span class="line"><span class="keyword">SAR</span> OPRD, <span class="built_in">CL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 逻辑右移指令，视为无符号数        </span></span><br><span class="line"><span class="keyword">SHR</span> OPRD, <span class="number">1</span></span><br><span class="line"><span class="keyword">SHR</span> OPRD, <span class="built_in">CL</span></span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/46007672f8e2139fa723af128b6b5f41941975311881900e46d6e8d2926b7d9f.png" alt="SAR 和 SHR" title>
                </div>
                <div class="image-caption">SAR 和 SHR</div>
            </figure>

<p>移出的数送 CF，移入 0 （算术右移）或符号位（逻辑右移）。</p>
<h5 id="不带-CF-的循环移位-ROL-ROR"><a href="#不带-CF-的循环移位-ROL-ROR" class="headerlink" title="不带 CF 的循环移位 ROL ROR"></a>不带 CF 的循环移位 ROL ROR</h5><p>二者都是在原数上循环移位，同时移出的数送 CF。见下。</p>
<h5 id="带-CF-的循环移位-RCL-RCR"><a href="#带-CF-的循环移位-RCL-RCR" class="headerlink" title="带 CF 的循环移位 RCL RCR"></a>带 CF 的循环移位 RCL RCR</h5><p>二者都是 CF 作为移入的数，移出的数再送 CF。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/71d57c3c15f9f63ab17f8b1613b7570bac1fd1a32e057d04e2d545424d0c86d1.png" alt="循环移位" title>
                </div>
                <div class="image-caption">循环移位</div>
            </figure>  

<p>循环移位可用于：</p>
<ul>
<li>用于对某些位状态的测试</li>
<li>高位部分和低位部分的交换</li>
<li>与非循环移位指令一起组成32位或更长字长数的移位</li>
</ul>
<p>例：对从存储单元 M 开始的三字数据执行左移一位。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SAL</span> M, <span class="number">1</span></span><br><span class="line"><span class="keyword">RCL</span> M+<span class="number">2</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">RCL</span> M+<span class="number">4</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/5cc3b593d59435947e0ba5e9ffee706d873d9e7a0031d7f506015b64c36384cf.png" alt="示例" title>
                </div>
                <div class="image-caption">示例</div>
            </figure>

<p>例 2：将 1000H 开始存放的 4 个压缩 BCD 码转换为 ASCII 码存放到 3000H 开始的单元中去。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">MOV</span> <span class="built_in">SI</span>, <span class="number">1000H</span></span><br><span class="line">      <span class="keyword">MOV</span> <span class="built_in">DI</span>, <span class="number">3000H</span></span><br><span class="line">      <span class="keyword">MOV</span> <span class="built_in">CX</span>, <span class="number">4</span></span><br><span class="line"><span class="symbol">Next:</span> <span class="keyword">MOV</span> <span class="built_in">AL</span>, [<span class="built_in">SI</span>]</span><br><span class="line">      <span class="keyword">MOV</span> <span class="built_in">BL</span>, <span class="built_in">AL</span>	    <span class="comment">; 由于每个字节有 2 个 BCD 码，需处理两次，故备份一个在 BL</span></span><br><span class="line">      <span class="keyword">AND</span> <span class="built_in">AL</span>, <span class="number">0FH</span></span><br><span class="line">      <span class="keyword">OR</span>  <span class="built_in">AL</span>, <span class="number">30H</span>     <span class="comment">; 处理 AL 的后四位</span></span><br><span class="line">      <span class="keyword">MOV</span> [<span class="built_in">DI</span>], <span class="built_in">AL</span></span><br><span class="line">      <span class="keyword">INC</span> <span class="built_in">DI</span>          <span class="comment">; 目的地地址 ++</span></span><br><span class="line">      <span class="keyword">MOV</span> <span class="built_in">AL</span>, <span class="built_in">BL</span></span><br><span class="line">      <span class="keyword">PUSH</span> <span class="built_in">CX</span>         <span class="comment">; 对 CX （用于计数剩余字节）备份</span></span><br><span class="line">      <span class="keyword">MOV</span> <span class="built_in">CL</span>, <span class="number">4</span>       <span class="comment">; 此处的 CL 为右移次数</span></span><br><span class="line">      <span class="keyword">SHR</span> <span class="built_in">AL</span>, <span class="built_in">CL</span>      <span class="comment">; 处理 AL 的前四位</span></span><br><span class="line">      <span class="keyword">OR</span>  <span class="built_in">AL</span>, <span class="number">30H</span></span><br><span class="line">      <span class="keyword">MOV</span> [<span class="built_in">DI</span>], <span class="built_in">AL</span></span><br><span class="line">      <span class="keyword">INC</span> <span class="built_in">DI</span>          <span class="comment">; 目的地地址 ++</span></span><br><span class="line">      <span class="keyword">INC</span> <span class="built_in">SI</span>          <span class="comment">; 源地址 ++</span></span><br><span class="line">      <span class="keyword">POP</span> <span class="built_in">CX</span></span><br><span class="line">      <span class="keyword">DEC</span> <span class="built_in">CX</span></span><br><span class="line">      <span class="keyword">JNZ</span> Next</span><br><span class="line">      <span class="keyword">HLT</span></span><br></pre></td></tr></table></figure>

<h3 id="串操作指令"><a href="#串操作指令" class="headerlink" title="串操作指令"></a>串操作指令</h3><ul>
<li>针对数据块或字符串的操作</li>
<li>实现存储器到存储器的数据传送（前面的所有命令都不能）</li>
</ul>
<p>串操作指令及其功能：（<code>&lt;=&gt;</code>表示比较，<code>&lt;-</code> 表示数据存储）</p>
<ul>
<li>串传送 <code>MOVS</code>：存储器  -&gt; 存储器</li>
<li>串比较 <code>CMPS</code>：存储器 &lt;=&gt; 存储器</li>
<li>串扫描 <code>SCAS</code>：存储器 &lt;=&gt; AL/AX </li>
<li>串装入 <code>LODS</code>：存储器  -&gt; AL/AX</li>
<li>串送存 <code>STOS</code>：存储器 &lt;-  AL/AX</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>源串地址由 <code>DS:[SI]</code> 提供，目的串由 <code>ES:[DI]</code> 提供</li>
<li>源串允许段（DS）重设，目的串不允许段（ES）重设。</li>
<li>每次：<ol>
<li>只处理串中的一个单元(字或字节)</li>
<li>这些指令执行结束后，都会按 <code>DF</code> 决定的方向自动修改 <code>SI</code> 和/或 <code>DI</code>，使其指向下一个单元（按指令可分别处理字单元和字节单元）</li>
</ol>
</li>
<li>地址修改方向由 DF 标志位决定：<ul>
<li><code>DF = 0</code> =&gt; 增地址方向</li>
<li><code>DF = 1</code> =&gt; 减地址方向</li>
</ul>
</li>
<li>指令前面可加上自动重复前缀，实现自动重复执行串操作，重复执行次数由 <code>CX</code> 指定</li>
</ul>
<h4 id="重复前缀"><a href="#重复前缀" class="headerlink" title="重复前缀"></a>重复前缀</h4><p>重复前缀：重复执行串操作指令时，每执行一次后，自动使 <code>CX-1=&gt;CX</code></p>
<ul>
<li>无条件重复<ul>
<li><code>REP</code> =&gt; 若 <code>CX≠0</code> 则重复</li>
</ul>
</li>
<li>条件重复<ul>
<li><code>REPE</code>  相等重复 =&gt; 若 <code>CX≠0</code> 且 <code>ZF=0</code> 则重复</li>
<li><code>REPZ</code>  为零重复（上一指令的别名）</li>
<li><code>REPNE</code> 不相等重复 =&gt; 若 <code>CX≠0</code> 且 <code>ZF≠0</code> 则重复</li>
<li><code>REPNZ</code> 不为零重复（上一指令的别名）<br>注意：<strong>重复前缀本身不改变标志位</strong></li>
</ul>
</li>
</ul>
<h4 id="串操作指令流程"><a href="#串操作指令流程" class="headerlink" title="串操作指令流程"></a>串操作指令流程</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/3ece5bd5b42862946c6175223499ee3b77fdc6cc7916ee57a572ceee0267d1bc.png" alt="串操作指令流程(以传送操作为例)" title>
                </div>
                <div class="image-caption">串操作指令流程(以传送操作为例)</div>
            </figure>  

<p>左边部分是串操作的初始化，右边的虚线框部分由串操作指令完成。</p>
<h4 id="串传送指令-MOVS"><a href="#串传送指令-MOVS" class="headerlink" title="串传送指令 MOVS"></a>串传送指令 MOVS</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOVS OPRD1(<span class="built_in">ES</span>:<span class="built_in">DI</span>), OPRD2(<span class="built_in">DS</span>:<span class="built_in">SI</span>)</span><br><span class="line"><span class="keyword">MOVSB</span></span><br><span class="line"><span class="keyword">MOVSW</span></span><br></pre></td></tr></table></figure>

<ul>
<li>第一种格式中，<code>OPRD1</code> 为目标串地址，<code>OPRD2</code> 为源串地址（类似于 <code>MOV</code>）。两串的段地址允许使用默认值（<code>ES</code>、<code>DS</code>），<strong>源串</strong>也允许段重设</li>
<li>二、三种格式下隐含了操作数地址（目标串 <code>ES:DI</code>、源串 <code>DS:SI</code>）</li>
<li><code>MOVSB</code> 一次完成一个 Byte 的传送，<code>MOVSW</code> 一次完成一个 Word 的传送</li>
<li>执行结束后，按 <code>DF</code> 决定的方向自动修改 <code>SI</code> 和 <code>DI</code>，使其指向下一个单元</li>
</ul>
<p>例题：用串传送指令实现200个字节数据的传送：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LEA</span>  <span class="built_in">SI</span>, MEM1</span><br><span class="line"><span class="keyword">LEA</span>  <span class="built_in">DI</span>, MEM2</span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">CX</span>, <span class="number">200</span></span><br><span class="line"><span class="keyword">CLD</span>              <span class="comment">; Clear Direction Flag: DF = 0</span></span><br><span class="line"><span class="keyword">REP</span>  <span class="keyword">MOVSB</span></span><br><span class="line"><span class="keyword">HLT</span></span><br></pre></td></tr></table></figure>

<h4 id="串比较指令-CMPS"><a href="#串比较指令-CMPS" class="headerlink" title="串比较指令 CMPS"></a>串比较指令 CMPS</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMPS OPRD1(<span class="built_in">DS</span>:<span class="built_in">SI</span>), OPRD2(<span class="built_in">ES</span>:<span class="built_in">DI</span>)</span><br><span class="line"><span class="keyword">CMPSB</span></span><br><span class="line"><span class="keyword">CMPSW</span></span><br></pre></td></tr></table></figure>

<ul>
<li>和 <code>MOVS</code> 相同的是，后两个命令默认目标串 <code>ES:DI</code>、源串 <code>DS:SI</code></li>
<li>和 <code>MOVS</code> 不同的是，<code>OPRD1</code> 为源串，<code>OPRD2</code> 为目标串（这和 <code>SUB</code>、<code>CMP</code> 相同）</li>
<li>执行 <code>OPRD1-OPRD2</code>，不送结果</li>
<li>串比较指令常与条件重复前缀连用</li>
<li>指令的执行不改变操作数，仅影响标志位</li>
<li>执行结束后，按 <code>DF</code> 决定的方向自动修改 <code>SI</code> 和 <code>DI</code>，使其指向下一个单元</li>
</ul>
<p>例：比较两组（200个字节）对应数据，找出第一个不同数据放入AL，其地址放入BX</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">LEA</span>  <span class="built_in">SI</span>, MEM1</span><br><span class="line">      <span class="keyword">LEA</span>  <span class="built_in">DI</span>, MEM2</span><br><span class="line">      <span class="keyword">MOV</span>  <span class="built_in">CX</span>, <span class="number">200</span></span><br><span class="line">      <span class="keyword">CLD</span></span><br><span class="line">      <span class="keyword">REPE</span> <span class="keyword">CMPSB</span>     <span class="comment">; 指令执行结束，可能是找到不同，也可能是完全相同</span></span><br><span class="line">      <span class="keyword">JZ</span>   STOP</span><br><span class="line">      <span class="keyword">DEC</span>  <span class="built_in">SI</span>        <span class="comment">; 注意！</span></span><br><span class="line">      <span class="keyword">MOV</span>  <span class="built_in">AL</span>，[<span class="built_in">SI</span>]</span><br><span class="line">      <span class="keyword">MOV</span>  <span class="built_in">BX</span>，<span class="built_in">SI</span></span><br><span class="line"><span class="symbol">STOP:</span> <span class="keyword">HLT</span></span><br></pre></td></tr></table></figure>

<p>上述 <code>DEC SI</code> 说明：<strong>当前 <code>REPE CMPSB</code> 条件不满足时，也会执行 <code>SI++</code> <code>DI++</code> <code>CX--</code>，然后停止执行指令。</strong></p>
<h4 id="串扫描指令-SCAS"><a href="#串扫描指令-SCAS" class="headerlink" title="串扫描指令 SCAS"></a>串扫描指令 SCAS</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SCAS  OPRD(<span class="built_in">ES</span>:<span class="built_in">DI</span>)</span><br><span class="line"><span class="keyword">SCASB</span></span><br><span class="line"><span class="keyword">SCASW</span></span><br></pre></td></tr></table></figure>

<ul>
<li>执行 <code>AX</code> （或 <code>AL</code>） - <code>OPRD</code>，结果不保存，只影响标志寄存器</li>
<li>常用于在指定存储区域中寻找关键字</li>
<li><code>OPRD</code> 为目标串，默认为 <code>ES:SI</code></li>
<li>执行结束后，按 <code>DF</code> 决定的方向自动修改 <code>DI</code>，使其指向下一个单元</li>
</ul>
<h4 id="串装入指令-LODS"><a href="#串装入指令-LODS" class="headerlink" title="串装入指令 LODS"></a>串装入指令 LODS</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LODS  OPRD(<span class="built_in">DS</span>:<span class="built_in">SI</span>)</span><br><span class="line"><span class="keyword">LODSB</span>              <span class="comment">; 存入 AL</span></span><br><span class="line"><span class="keyword">LODSW</span>              <span class="comment">; 存入 AX</span></span><br></pre></td></tr></table></figure>

<ul>
<li>用于将内存某个区域的数据串依次装入累加寄存器  AX/AL ，以便进行处理</li>
<li>不影响标志位</li>
<li><code>LODS</code> 指令加重复前缀无意义（等价于 <code>LOAD</code> 最后一个有效值）</li>
<li>执行结束后，按 <code>DF</code> 决定的方向自动修改 <code>SI</code>，使其指向下一个单元（这即是和 <code>MOV AL, [SI]</code> 的最大区别）</li>
</ul>
<h4 id="串存储指令-STOS"><a href="#串存储指令-STOS" class="headerlink" title="串存储指令 STOS"></a>串存储指令 STOS</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STOS  OPRD(<span class="built_in">ES</span>:<span class="built_in">DI</span>)</span><br><span class="line"><span class="keyword">STOSB</span>              <span class="comment">; 将 AL 存入内存</span></span><br><span class="line"><span class="keyword">STOSW</span>              <span class="comment">; 将 AX 存入内存</span></span><br></pre></td></tr></table></figure>

<p>配合重复前缀，常用于将内存某个区域置同样的值。</p>
<h4 id="串操作指令注意事项"><a href="#串操作指令注意事项" class="headerlink" title="串操作指令注意事项"></a>串操作指令注意事项</h4><p>注意事项：</p>
<ul>
<li>需要定义附加段<ul>
<li>目标操作数必须在附加段</li>
</ul>
</li>
<li>需要设置数据的操作方向<ul>
<li>确定 <code>DF</code> 的状态</li>
</ul>
</li>
<li>源串和目标串指针分别为 <code>SI</code> 和 <code>DI</code></li>
<li>串长度值必须由 <code>CX</code> 给出</li>
<li>注意重复前缀的使用方法<ul>
<li>传送类指令前加无条件重复前缀</li>
<li>串比较类指令前加条件重复前缀，但前缀不影响 <code>ZF</code> 状态</li>
</ul>
</li>
</ul>
<h3 id="程序控制指令"><a href="#程序控制指令" class="headerlink" title="程序控制指令"></a>程序控制指令</h3><h4 id="程序的执行方向"><a href="#程序的执行方向" class="headerlink" title="程序的执行方向"></a>程序的执行方向</h4><ul>
<li>程序控制类指令的本质：<strong>控制程序的执行顺序</strong></li>
<li>决定程序执行方向的因素：<code>CS</code>，<code>IP</code></li>
<li>下条指令地址：<code>CS:[IP]</code></li>
<li>修改 <code>CS</code>，程序转向另一个代码段执行</li>
<li>修改 <code>IP</code>，程序转向本代码段内另一处执行</li>
</ul>
<h4 id="转移指令-JMP"><a href="#转移指令-JMP" class="headerlink" title="转移指令 JMP"></a>转移指令 JMP</h4><ul>
<li>转移指令修改 <code>CS</code> 和 <code>IP</code> 的值，实现程序转移</li>
<li>分为无条件转移指令和有条件转移指令</li>
</ul>
<h5 id="无条件转移指令"><a href="#无条件转移指令" class="headerlink" title="无条件转移指令"></a>无条件转移指令</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">JMP</span>  OPRD</span><br></pre></td></tr></table></figure>

<h6 id="段内转移"><a href="#段内转移" class="headerlink" title="段内转移"></a>段内转移</h6><ul>
<li>段内转移：目标地址为 16 位，赋值给 <code>IP</code></li>
<li>段内直接转移：<code>OPRD/Label</code> 为立即数，<strong><code>IP &lt;= IP + Label</code></strong>（<code>Label</code> 被汇编为 8/16 位位移量）</li>
<li>段内间接转移：<code>OPRD</code> 为寄存器或存储器，<strong><code>IP &lt;= OPRD</code></strong></li>
</ul>
<p>例题：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">JMP</span>  Next        <span class="comment">; Next 为标号</span></span><br><span class="line"><span class="comment">; 执行后 IP 到 Next 所在指令的地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">JMP</span>  <span class="built_in">BX</span>          <span class="comment">;  BX  = 1200H</span></span><br><span class="line"><span class="comment">; 执行后 IP = 1200H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">JMP</span>  [<span class="built_in">BX</span>]        <span class="comment">; [BX] = 4312H </span></span><br><span class="line"><span class="comment">; 执行后 IP = 4312H。</span></span><br></pre></td></tr></table></figure>

<p>关于 Label 的详细介绍可见<a href="#标号">标号</a>。</p>
<h6 id="段间转移-JMP-FAR"><a href="#段间转移-JMP-FAR" class="headerlink" title="段间转移 JMP FAR"></a>段间转移 JMP FAR</h6><ul>
<li>段间转移：目标地址为 32 位，赋值给 <code>CS:IP</code></li>
<li>段内直接转移：<code>OPRD/Label</code> 为立即数，<code>CS:IP = Label</code>（<code>Label</code> 被汇编为 32 位地址）</li>
</ul>
<p>例：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">JMP</span>  <span class="built_in">FAR</span> Label      <span class="comment">; 段内直接转移</span></span><br><span class="line"><span class="comment">; CS:IP = Label</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">JMP</span>  <span class="built_in">DWORD</span> <span class="built_in">PTR</span>[<span class="built_in">BX</span>]  <span class="comment">; 段内间接寻址</span></span><br><span class="line"><span class="comment">; IP = [BX]</span></span><br><span class="line"><span class="comment">; CS = [BX+1]</span></span><br></pre></td></tr></table></figure>

<p>例 2：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span>  <span class="built_in">SI</span>，<span class="number">1122H</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">WORD</span> <span class="built_in">PTR</span>[<span class="built_in">SI</span>]，<span class="number">0120H</span></span><br><span class="line"><span class="keyword">ADD</span>  <span class="built_in">SI</span>，<span class="number">2</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">WORD</span> <span class="built_in">PTR</span>[<span class="built_in">SI</span>]，<span class="number">0122H</span></span><br><span class="line"><span class="keyword">JMP</span> <span class="built_in">DWORD</span> <span class="built_in">PTR</span>[<span class="built_in">SI</span>-<span class="number">2</span>]</span><br><span class="line"><span class="comment">; CS = 0122H, IP = 0120H</span></span><br></pre></td></tr></table></figure>

<p>注意第二行，将立即数存入内存时，必须使用 <code>BYTE/WORD PTR</code> 显式指明立即数的长度是 8 位还是 16 位。寄存器值存入内存则不需要，因为寄存器隐式地给出了长度。</p>
<h5 id="条件转移指令"><a href="#条件转移指令" class="headerlink" title="条件转移指令"></a>条件转移指令</h5><ul>
<li>在满足一定条件下，程序转移到目标地址继续执行</li>
<li>条件转移指令均为<strong>直接寻址的段内短转移</strong>，即转移的位移量为 8 位补码表示，范围为：<strong>-128~+127</strong><br>IP=IP+位移量</li>
</ul>
<p>常见条件指令的应用：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>条件</th>
<th>应用</th>
</tr>
</thead>
<tbody><tr>
<td><code>JC/JNC</code></td>
<td>判断<code>CF</code>的状态</td>
<td>常用于比大小</td>
</tr>
<tr>
<td><code>JZ/JNZ</code></td>
<td>判断<code>ZF</code>的状态</td>
<td>常用于循环体的结束判断</td>
</tr>
<tr>
<td><code>JO/JNO</code></td>
<td>判断<code>OF</code>的状态</td>
<td>常用于有符号数溢出的判断</td>
</tr>
<tr>
<td><code>JP/JNP</code></td>
<td>判断<code>PF</code>的状态。用于判断运算结果低8位中1的个数是否为偶数</td>
<td></td>
</tr>
<tr>
<td><code>JA/JAE/JB/JBE</code></td>
<td>判断<code>CF</code>或<code>CF+ZF</code>的状态</td>
<td>常用于无符号数的大小比较</td>
</tr>
<tr>
<td><code>JG/JGE/JL/JLE</code></td>
<td>判断<code>SF</code>、<code>OF</code>和<code>ZF</code>的状态</td>
<td>常用于带符号数的大小比较</td>
</tr>
</tbody></table>
<p>例题：统计内存数据段中以 TABLE 为首地址的 100 个 8 位有符号数中正数、负数和零的个数。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/282107de057cb912c39b1e4280688ca798324e448b4123a35dec7d4355b2ddd1.png" alt="例题程序" title>
                </div>
                <div class="image-caption">例题程序</div>
            </figure>

<h4 id="循环控制指令"><a href="#循环控制指令" class="headerlink" title="循环控制指令"></a>循环控制指令</h4><ul>
<li>循环范围：以当前 <code>IP</code> 为中心的 <code>-128～+127</code> 范围内循环</li>
<li>循环次数：由 <code>CX</code> 寄存器指定</li>
<li>循环指令：<code>LOOP</code> <code>LOOPZ</code> <code>LOOPNZ</code></li>
</ul>
<h5 id="无条件循环指令-LOOP"><a href="#无条件循环指令-LOOP" class="headerlink" title="无条件循环指令 LOOP"></a>无条件循环指令 LOOP</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">LOOP  LABEL</span></span><br></pre></td></tr></table></figure>

<ul>
<li>操作： </li>
</ul>
<ol>
<li><code>CX-1 =&gt; CX</code></li>
<li><code>CX ≠ 0</code> 则转 <code>LABEL</code>，否则执行下条指令</li>
</ol>
<p>也就是说，当 <code>CX = 1</code> 时执行 <code>LOOP</code> 则不会跳转，而是顺序执行。</p>
<h5 id="有条件循环指令-LOOPZ-LOOPNZ（略）"><a href="#有条件循环指令-LOOPZ-LOOPNZ（略）" class="headerlink" title="有条件循环指令 LOOPZ LOOPNZ（略）"></a>有条件循环指令 LOOPZ LOOPNZ（略）</h5><p><code>LOOPZ</code> 和 <code>LOOPNZ</code></p>
<h4 id="过程调用指令-CALL"><a href="#过程调用指令-CALL" class="headerlink" title="过程调用指令 CALL"></a>过程调用指令 CALL</h4><ul>
<li>用于调用一个子过程</li>
<li>子过程由程序员预先设计并装入内存</li>
<li>子过程执行结束后要返回原调用处</li>
<li>重要概念：入口地址、断点，如图</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/75d5aab2e89484cb5e629d88f5b36a4574c3bd86224bbda12a5ec56bd0865b75.png" alt="入口地址和断点" title>
                </div>
                <div class="image-caption">入口地址和断点</div>
            </figure>  

<p>调用指令的执行过程：</p>
<ol>
<li>保护断点：将断点（调用指令的下一条指令的地址）压栈</li>
<li>获取子过程的入口地址（子过程第一条指令的地址）</li>
<li>执行子过程，含相应参数的保存及恢复</li>
<li>恢复断点，返回原程序（将断点地址由堆栈弹出）</li>
</ol>
<p>分为：</p>
<ul>
<li>段内直接调用</li>
<li>段内间接调用</li>
<li>段间直接调用</li>
<li>段间间接调用</li>
</ul>
<h5 id="段内调用-CALL-NEAR"><a href="#段内调用-CALL-NEAR" class="headerlink" title="段内调用 CALL NEAR"></a>段内调用 CALL NEAR</h5><p>由于被调用程序与调用程序在同一代码段，调用前只需保护断点的偏移地址。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span>  (<span class="built_in">NEAR</span>)  PROC</span><br></pre></td></tr></table></figure>

<p>执行过程：</p>
<ul>
<li>断点压栈</li>
<li><code>PROC =&gt; IP</code></li>
</ul>
<p>例：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span>  TIMER           <span class="comment">; 直接调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span>  <span class="built_in">WORD</span>  <span class="built_in">PTR</span>[<span class="built_in">SI</span>]   <span class="comment">; 间接调用，指明长度为 16 位，是段内调用</span></span><br><span class="line"><span class="comment">; 执行后 IP = [SI], CS 不变</span></span><br></pre></td></tr></table></figure>

<h5 id="段间调用-CALL-FAR"><a href="#段间调用-CALL-FAR" class="headerlink" title="段间调用 CALL FAR"></a>段间调用 CALL FAR</h5><p>由于子过程与原调用程序不在同一代码段，调用前需保护断点的段基地址和偏移地址。</p>
<p><strong>先将 <code>CS</code> 压栈，再压入 <code>IP</code>。</strong></p>
<p>格式：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span>  <span class="built_in">FAR</span>  PROC</span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span>  <span class="built_in">FAR</span>  TIMER</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span>  <span class="built_in">DWORD</span>  <span class="built_in">PTR</span>[<span class="built_in">SI</span>]    <span class="comment">; 指明长度为 32 位，是段间调用</span></span><br><span class="line"><span class="comment">; 执行后 IP = [SI]</span></span><br><span class="line"><span class="comment">; CS = [SI+2]</span></span><br></pre></td></tr></table></figure>

<h5 id="返回指令-RET"><a href="#返回指令-RET" class="headerlink" title="返回指令 RET"></a>返回指令 RET</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RET</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从堆栈中弹出断点地址，返回原程序</li>
<li>一般位于子程序的最后</li>
<li>在格式上不区分段内或段间</li>
</ul>
<h4 id="中断控制指令"><a href="#中断控制指令" class="headerlink" title="中断控制指令"></a>中断控制指令</h4><h5 id="中断和过程调用的区别"><a href="#中断和过程调用的区别" class="headerlink" title="中断和过程调用的区别"></a>中断和过程调用的区别</h5><ul>
<li>中断是随机事件或异常事件引起，调用则是事先已在程序中安排好</li>
<li>响应中断请求不仅要保护断点地址，还要保护 <code>FLAGS</code> 内容</li>
<li>调用指令在指令中直接给出子程序入口地址</li>
<li>中断指令只给出中断向量码，入口地址则在中断向量码指向的中断向量表（内存单元）中</li>
</ul>
<h5 id="中断指令-INT"><a href="#中断指令-INT" class="headerlink" title="中断指令 INT"></a>中断指令 INT</h5><p>中断指令，又称作软中断指令</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INT</span>  n</span><br><span class="line"><span class="comment">; n*4 为中断服务程序入口的偏移地址（段地址 = DS）</span></span><br><span class="line"><span class="comment">; 8086 的中断向量表存放在内存最低的 1K 单元</span></span><br></pre></td></tr></table></figure>

<h5 id="中断指令的执行过程"><a href="#中断指令的执行过程" class="headerlink" title="中断指令的执行过程"></a>中断指令的执行过程</h5><ul>
<li>将 <code>FLAGS</code> 压入堆栈</li>
<li>将 <code>INT</code> 指令的下一条指令的 <code>CS</code>、<code>IP</code> 压栈</li>
<li>由 <code>n*4</code> 得到存放中断向量的地址</li>
<li>将中断向量（中断服务程序入口地址）送 <code>CS</code> 和 <code>IP</code> 寄存器<ul>
<li><code>CS = DS:[n*4]</code></li>
<li><code>IP = DS:[n*4+2]</code></li>
</ul>
</li>
<li>转入中断服务程序</li>
</ul>
<p>下图中，左图为中断后的堆栈段，右图为数据段和代码段。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/5370d71c8a40900e23d1a12d8c5c48f6229a59dfb1504056cce3b0e71c180fc0.png" alt="中断指令的执行过程" title>
                </div>
                <div class="image-caption">中断指令的执行过程</div>
            </figure>  

<p>例：</p>
<p><code>[0084H] = 1123H</code>, <code>[0086H] = 2000H</code>。执行 <code>INT 21H</code> 后，</p>
<ul>
<li><code>IP = [21H*4] = 1123H</code></li>
<li><code>CS = [21H*4+2] = 2000H</code></li>
<li>下一条指令在 <code>21123H</code></li>
</ul>
<h5 id="溢出中断指令-INTO"><a href="#溢出中断指令-INTO" class="headerlink" title="溢出中断指令 INTO"></a>溢出中断指令 INTO</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INTO</span></span><br></pre></td></tr></table></figure>

<ul>
<li>指令执行时检查 <code>OF</code> 标志：<ul>
<li>若 <code>OF=1</code>，则启动一个类型为4的中断过程,即相当于执行指令: <code>INT 4</code></li>
<li>若 <code>OF=0</code>，不做任何操作执行下一条指令</li>
</ul>
</li>
<li><code>INTO</code> 指令通常安排在有符号数加减运算指令之后判断是否发生溢出</li>
</ul>
<h5 id="中断返回指令-ITER"><a href="#中断返回指令-ITER" class="headerlink" title="中断返回指令 ITER"></a>中断返回指令 ITER</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">IRET</span></span><br></pre></td></tr></table></figure>

<ul>
<li>中断服务程序的最后一条指令，执行：<ol>
<li>恢复断点</li>
<li>恢复标志寄存器内容</li>
</ol>
</li>
</ul>
<h4 id="处理器控制指令"><a href="#处理器控制指令" class="headerlink" title="处理器控制指令"></a>处理器控制指令</h4><p>主要分为：</p>
<ul>
<li>对标志位的操作<ul>
<li>对标志位操作都是无操作数指令</li>
<li>可操作的标志位有 <code>CF</code>、<code>IF</code>和<code>DF</code></li>
</ul>
</li>
<li>与外部设备的同步</li>
</ul>
<table>
<thead>
<tr>
<th>常见指令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>CLC</code> (clear CF)</td>
<td>清除进位标志</td>
</tr>
<tr>
<td><code>STC</code> (set CF)</td>
<td>置1进位标志</td>
</tr>
<tr>
<td><code>CMC</code> (complement CF)</td>
<td>进位标志取反</td>
</tr>
<tr>
<td><code>CLD</code></td>
<td>清除方向标志</td>
</tr>
<tr>
<td><code>STD</code></td>
<td>置1方向标志</td>
</tr>
<tr>
<td><code>CLI</code></td>
<td>清除中断标志</td>
</tr>
<tr>
<td><code>STI</code></td>
<td>置1中断标志</td>
</tr>
</tbody></table>
<h2 id="汇编语言程序设计"><a href="#汇编语言程序设计" class="headerlink" title="汇编语言程序设计"></a>汇编语言程序设计</h2><h3 id="汇编语言语句种类及其格式"><a href="#汇编语言语句种类及其格式" class="headerlink" title="汇编语言语句种类及其格式"></a>汇编语言语句种类及其格式</h3><p>汇编语言语句分为指令语句和伪指令语句。</p>
<h4 id="指令语句"><a href="#指令语句" class="headerlink" title="指令语句"></a>指令语句</h4><p>每一条指令语句在汇编时都要产生一个可供CPU执行的机器目标代码，它又叫可执行语句。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/20a5c3d0761cc76031f79f5614dfcd829e3fa595afa28c3ed9ec8e811e2b4855.png" alt="指令语句的一般格式" title>
                </div>
                <div class="image-caption">指令语句的一般格式</div>
            </figure>

<ul>
<li>指令助记符和操作数两个字段就是<a href="#指令系统">指令系统</a>介绍的指令</li>
<li>标号是可选字段，后面必须跟 <code>:</code><ul>
<li>主要用于控制程序执行顺序</li>
</ul>
</li>
<li>注释字段为可选项，以分号 <code>;</code> 开始<ul>
<li>它不会产生机器目标代码，不影响程序的功能</li>
<li>注释可以加在指令的后面，也可以是整个语句行</li>
</ul>
</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">LABEL1:</span> <span class="keyword">ADD</span>  <span class="built_in">AX</span>, <span class="built_in">BX</span>  <span class="comment">;功能为AX&lt;=(AX)+(BX)</span></span><br><span class="line"><span class="comment">; 后面的程序段将完成一次对存储器的访问</span></span><br></pre></td></tr></table></figure>

<h4 id="伪指令语句"><a href="#伪指令语句" class="headerlink" title="伪指令语句"></a>伪指令语句</h4><ul>
<li>伪指令语句又叫命令语句，是指示性语句</li>
<li>伪指令本身不产生自己的机器目标代码，它指示汇编程序对其后面的指令语句和伪指令语句如何处理</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/740e07dc751a8a621249923fc873f59e1eed613e8ef78cde4a10a5c13ab81c66.png" alt="伪指令语句的一般格式" title>
                </div>
                <div class="image-caption">伪指令语句的一般格式</div>
            </figure>

<h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>指令语句中的标号和伪指令语句中的符号名统称为标识符，它由若干个字符构成。</p>
<p>标识符构成规则：</p>
<ul>
<li>字符的个数为 1-31 个</li>
<li>可以使用字母、数字、<code>@</code> 、 <code>_</code>或 <code>?</code></li>
<li>不能以数字开头</li>
<li>不能使用系统专用的保留字</li>
</ul>
<h4 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h4><ul>
<li>CPU 中各寄存器名（如 <code>AX</code>、<code>CS</code> 等）</li>
<li>指令助记符（如<code>MOV</code>、<code>ADD</code>）</li>
<li>伪指令符（如<code>SEGMENT</code>、<code>DB</code>）</li>
<li>表达式中的运算符（如<code>GE</code>、<code>EQ</code>）</li>
<li>属性操作符（如<code>PTR</code>、<code>OFFSET</code>等）</li>
</ul>
<h3 id="汇编语言数据"><a href="#汇编语言数据" class="headerlink" title="汇编语言数据"></a>汇编语言数据</h3><ul>
<li>数据：指令和伪指令语句中的操作数</li>
<li>常用的数据形式有：<strong>常数</strong>、<strong>变量</strong>和<strong>标号</strong></li>
<li>一个数据由<strong>数值</strong>和<strong>属性</strong>（比如是字节数据还是字数据）两部分构成</li>
</ul>
<h4 id="常数"><a href="#常数" class="headerlink" title="常数"></a>常数</h4><p>常数：经过汇编后其值已完全确定，并且在程序运行过程中不会改变。</p>
<h5 id="常量的表示"><a href="#常量的表示" class="headerlink" title="常量的表示"></a>常量的表示</h5><ul>
<li>二进制数：以字母 <code>B</code> 结尾，如 <code>01001001B</code></li>
<li>八进制数：以字母 <code>O</code> 或 <code>Q</code> 结尾，如<code>631Q</code> <code>254O</code></li>
<li>十进制数：以字母 <code>D</code> 结尾，或者没有结尾字母。如 <code>2007D</code>、<code>2007</code></li>
<li>十六进制数：以字母 <code>H</code> 结尾，如 <code>3FEH</code><ul>
<li>如果常数的第一个数符为字母，为了与标识符区别，必须在其前面冠以数字 <code>0</code>，如<code>0F000H</code> 为 16 位常数</li>
</ul>
</li>
<li>实数：如 <code>2.134E+10</code>。汇编源程序时会把实数转换为 4 字节、8 字节或 10 字节的二进制数形式存放。</li>
<li>字符串常数：用引号（单引号或双引号）括起来的一个或多个字符，其值为这些字符的ASCII码<ul>
<li>如 <code>&#39;ABC&#39;</code> 存储为 <code>41H 42H 43H</code></li>
<li>其中 <code>41H</code> 在低地址，<code>43H</code> 在高地址，类似于 C 语言的 <code>char *</code></li>
</ul>
</li>
</ul>
<h5 id="常数的作用"><a href="#常数的作用" class="headerlink" title="常数的作用"></a>常数的作用</h5><ol>
<li>作指令语句的源操作数</li>
<li>在指令语句中作位移量</li>
<li>在数据定义伪指令中使用</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 1. 作指令语句的源操作数</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">AX</span>,  <span class="number">0B2F0H</span></span><br><span class="line"><span class="keyword">ADD</span>  <span class="number">AH</span>,  <span class="number">64H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 2. 在指令语句中作位移量</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">BX</span>, <span class="number">32H</span> [<span class="built_in">SI</span>]</span><br><span class="line"><span class="keyword">MOV</span>  <span class="number">0ABH</span> [<span class="built_in">BX</span>], <span class="built_in">CX</span></span><br><span class="line"><span class="keyword">ADC</span>  <span class="built_in">DX</span>, <span class="number">1234H</span>[<span class="built_in">BP</span>][<span class="built_in">DI</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">; 3. 在数据定义伪指令中使用</span></span><br><span class="line"><span class="built_in">DB</span>   <span class="number">10H</span> </span><br><span class="line"><span class="built_in">DW</span>   <span class="number">3210H</span></span><br></pre></td></tr></table></figure>

<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>变量：用来表示存放数据的存储单元，这些数据在程序运行期间可以被改变。</p>
<p>程序中以变量名的形式来访问变量。<strong>变量名就是存放数据的存储单元地址</strong>。</p>
<h5 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h5><p>定义变量：给变量在内存中分配一定的存储单元。也就是给这个存储单元赋与一个符号名，即变量名，同时还要将这些存储单元预置初置。</p>
<p>定义变量使用数据定义伪指令 <code>DB</code>、<code>DW</code>、<code>DD</code>、<code>DQ</code> 和 <code>DT</code> 等。</p>
<p>格式：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VAR_DATA <span class="meta">SEGMENT</span></span><br><span class="line">DATA1 <span class="built_in">DB</span> <span class="number">12H</span></span><br><span class="line"><span class="comment">; 变量名 + 数据定义伪指令 + 初值</span></span><br><span class="line">DATA2 <span class="built_in">DB</span> <span class="number">20H</span>, <span class="number">30H</span></span><br><span class="line">DATA3 <span class="built_in">DW</span> <span class="number">5678H</span></span><br><span class="line">VAR_DATA ENDS</span><br></pre></td></tr></table></figure>

<h5 id="变量的属性"><a href="#变量的属性" class="headerlink" title="变量的属性"></a>变量的属性</h5><ol>
<li>段属性（逻辑段）：上例 <code>DATA1</code> <code>DATA2</code> <code>DATA3</code> 均在 <code>VAR_DATA</code> 逻辑段</li>
<li>偏移量属性（偏移地址）：上例 <code>DATA1</code> <code>DATA2</code> <code>DATA3</code> 的偏移量分别为 0, 1, 3</li>
<li>类型属性，如下：</li>
</ol>
<table>
<thead>
<tr>
<th>类型</th>
<th>中文</th>
<th>变量长度</th>
</tr>
</thead>
<tbody><tr>
<td><code>DB</code></td>
<td>Define Byte</td>
<td>1 字节</td>
</tr>
<tr>
<td><code>DW</code></td>
<td>Define Word</td>
<td>2 字节</td>
</tr>
<tr>
<td><code>DD</code></td>
<td>Define Double word</td>
<td>4 字节</td>
</tr>
<tr>
<td><code>DQ</code></td>
<td>Defind Quadword</td>
<td>8 字节</td>
</tr>
<tr>
<td><code>DT</code></td>
<td>Define Tenbytes</td>
<td>10 字节</td>
</tr>
</tbody></table>
<h5 id="变量的预置"><a href="#变量的预置" class="headerlink" title="变量的预置"></a>变量的预置</h5><ol>
<li>数值表达式</li>
<li><code>?</code> 表达式：表示预置任意内容（未赋初值）</li>
<li>字符串表达式</li>
<li><code>DUP</code> 表达式</li>
</ol>
<h6 id="数值表达式"><a href="#数值表达式" class="headerlink" title="数值表达式"></a>数值表达式</h6><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 1. 数值表达式</span></span><br><span class="line">DATA1  <span class="built_in">DB</span>  <span class="number">32</span>, <span class="number">30H</span></span><br><span class="line"><span class="comment">; DATA1 的内容为 32（20H）</span></span><br><span class="line"><span class="comment">; DATA1+1 单元内容为30H</span></span><br></pre></td></tr></table></figure>

<h6 id="表达式"><a href="#表达式" class="headerlink" title="? 表达式"></a>? 表达式</h6><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DA-<span class="built_in">BYTE</span> <span class="built_in">DB</span> ?, ?, ?</span><br><span class="line"><span class="comment">; 表示让汇编程序分配三个字节存储单元</span></span><br><span class="line"><span class="comment">; 这些存储单元的内容的值为任意（未赋初值）</span></span><br></pre></td></tr></table></figure>

<h6 id="字符串表达式"><a href="#字符串表达式" class="headerlink" title="字符串表达式"></a>字符串表达式</h6><ul>
<li>字符串长度不超过 255 个字符</li>
<li>使用 <code>DB</code> 伪指令，会对每个字符分配一个字节单元，从左到右将各字符的 ASCII 码以地址递增的顺序依次存放</li>
<li>使用 <code>DW</code> 伪指令，可以给两个字符组成的字符串分配两个字节存储单元<ul>
<li>但需要注意的是，两个字符的存放顺序是前一个字符放在高地址，后一字符放低地址单元</li>
</ul>
</li>
<li>使用 <code>DD</code> 伪指令，只能给<strong>两个字符</strong>组成的字符串分配 <strong>4 个字节单元</strong><ul>
<li>两个字符存放在较低地址的两个字节单元中，存放顺序与 <code>DW</code> 伪指令相同</li>
<li>而较高地址的两个字节单元存放 0</li>
</ul>
</li>
<li><code>DW</code> 和 <code>DD</code> 伪指令不能用两个以上字符构成的字符串赋初值</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 3. 字符串表达式</span></span><br><span class="line">STRING1  <span class="built_in">DB</span>  <span class="string">'ABCDEF'</span></span><br><span class="line"><span class="comment">; 低地址到高地址依次为 'A' 'B' 'C' 'D' 'E' 'F'</span></span><br><span class="line"></span><br><span class="line">STRING2 <span class="built_in">DW</span> <span class="string">'AB'</span>, <span class="string">'CD'</span>, <span class="string">'EF'</span></span><br><span class="line"><span class="comment">; 低地址到高地址依次为 'B' 'A' 'D' 'C' 'F' 'E'</span></span><br><span class="line"></span><br><span class="line">STRING3 <span class="built_in">DD</span>, <span class="string">'AB'</span>, <span class="string">'CD'</span></span><br><span class="line"><span class="comment">; 低地址到高地址依次为 'B' 'A' 0 0 'D' 'C' 0 0</span></span><br></pre></td></tr></table></figure>

<h6 id="DUP-表达式"><a href="#DUP-表达式" class="headerlink" title="DUP 表达式"></a>DUP 表达式</h6><p>DUP 称为重复数据操作符。其格式为：<code>变量名</code> + <code>数据定义伪指令</code> + <code>重复次数</code></p>
<ul>
<li><code>DUP</code> + <code>(重复内容)</code>。</li>
</ul>
<p>如：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DATA_A <span class="built_in">DB</span> <span class="number">10H</span> DUP(?)</span><br><span class="line"><span class="comment">; 分配 16 个字节单元，不赋初值</span></span><br><span class="line"></span><br><span class="line">DATA_B <span class="built_in">DB</span> <span class="number">20H</span> DUP(<span class="string">'AB'</span>)</span><br><span class="line"><span class="comment">; 分配 20H * 2 = 64 个字节单元，其内容为 'AB'</span></span><br></pre></td></tr></table></figure>

<p><strong>嵌套的 <code>DUP</code></strong>：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DATA_C <span class="built_in">DB</span> <span class="number">10H</span> DUP(<span class="number">4</span> DUP(<span class="number">2</span>), <span class="number">7</span>)</span><br><span class="line"><span class="comment">; 重复 10H 个数字序列（2、2、2、2、7），共占用 10H*5 = 50H 字节</span></span><br></pre></td></tr></table></figure>

<h6 id="地址表达式"><a href="#地址表达式" class="headerlink" title="地址表达式"></a>地址表达式</h6><p>该地址表达式为一变量名（或标号名），那么：</p>
<ul>
<li>用伪指令 <code>DW</code> 定义则是用它的<strong>偏移量</strong>来初始化变量</li>
<li>用伪指令 <code>DD</code> 定义则是用它的<strong>段基值和偏移量</strong>来初始化变量，且段基值存放在高字单元，偏移量存放在低字单元</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 设以下变量的段基址为 0915H，NUM 的偏移地址为 0004H</span></span><br><span class="line">NUM   <span class="built_in">DB</span> <span class="number">75H</span></span><br><span class="line">ARRAY <span class="built_in">DW</span> <span class="number">20H</span> DUP(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ADR1  <span class="built_in">DW</span> NUM         <span class="comment">; DW 时取 NUM 的偏移地址</span></span><br><span class="line"><span class="comment">; ADR1 = 0004H</span></span><br><span class="line"></span><br><span class="line">ADR2  <span class="built_in">DD</span> NUM         <span class="comment">; DD 时取 NUM 的偏移地址（存入低字）和段基址（存入）</span></span><br><span class="line"><span class="comment">; ADR2 = 0915 0004H</span></span><br><span class="line"></span><br><span class="line">ADR3  <span class="built_in">DW</span> ARRAY[<span class="number">2</span>]</span><br><span class="line"><span class="comment">; ADR3 = 0007H</span></span><br></pre></td></tr></table></figure>

<p>注意：变量不能出现在 <code>DB</code> 语句的右边，因为变量的偏移地址为 16 位，与 <code>DB</code> 定义的变量长度不匹配。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/b0511e29b7cdda8e6854a123995af5eb1ba0228928dc5157ff13bb2d0d100edd.png" alt="语句运行后的内存" title>
                </div>
                <div class="image-caption">语句运行后的内存</div>
            </figure>  

<h6 id="以上表达式组成的序列"><a href="#以上表达式组成的序列" class="headerlink" title="以上表达式组成的序列"></a>以上表达式组成的序列</h6><p>如下：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NUM DB <span class="number">2</span> DUP(<span class="number">1</span>), <span class="number">2</span> DUP(<span class="number">2</span>, 'B'), '<span class="number">123</span>', <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">; NUM 从低地址到高地址分别为 <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> 'B' <span class="number">2</span> 'B' '<span class="number">1</span>' '<span class="number">2</span>' '<span class="number">3</span>' <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h5 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h5><p>在指令语句中，<strong>直接引用变量名就是对其存储单元的内容进行存取</strong>。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DA1  <span class="built_in">DB</span> <span class="number">0FEH</span></span><br><span class="line">DA2  <span class="built_in">DW</span> <span class="number">52ACH</span></span><br><span class="line">DA3  <span class="built_in">DW</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">AL</span>, DA1   <span class="comment">; 等价于 MOV  AL, 0FEH</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">BX</span>, DA2   <span class="comment">; 等价于 MOV  BX, 52ACH</span></span><br><span class="line"><span class="keyword">MOV</span>  DA3, <span class="built_in">BX</span>   <span class="comment">; 将 DA3 变量赋值 52ACH，注意二者大小需要对应</span></span><br><span class="line"><span class="comment">; 变量是可以被重复赋值的</span></span><br></pre></td></tr></table></figure>

<p>可以认为<strong>指令语句中，变量的地位等同于常量</strong>。</p>
<h5 id="符号和变量对比"><a href="#符号和变量对比" class="headerlink" title="符号和变量对比"></a>符号和变量对比</h5><p>|符号|变量<br>-|-|-<br>可变与否|类似于常量，不可变|可变<br>定义|<code>EQU</code>或<code>=</code>|<code>DB</code> <code>DW</code> 等<br>地址空间|无|有段基址、偏移地址</p>
<h4 id="标号"><a href="#标号" class="headerlink" title="标号"></a>标号</h4><ul>
<li>标号 <code>label</code> 加在一条指令的前面，它就是该指令在内存的存放地址的符号表示，也就是指令地址的别名</li>
<li>标号主要用在程序中需要改变程序的执行顺序时，用来标记转移的目的地</li>
<li>下面代码的 <code>LAB</code> 和 <code>NEXT</code> 即为标号</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">MOV</span>  <span class="built_in">CX</span>, <span class="number">100</span></span><br><span class="line"><span class="symbol">LAB:</span>  <span class="keyword">MOV</span>  <span class="built_in">AX</span>, <span class="built_in">BX</span></span><br><span class="line">      <span class="comment">; ...</span></span><br><span class="line">      <span class="keyword">LOOP</span> LAB</span><br><span class="line">      <span class="keyword">JNE</span> NEXT       <span class="comment">;不为零转移</span></span><br><span class="line">      <span class="comment">; ...</span></span><br><span class="line"><span class="symbol">NEXT:</span> <span class="comment">; ...</span></span><br></pre></td></tr></table></figure>

<h5 id="标号的三个属性"><a href="#标号的三个属性" class="headerlink" title="标号的三个属性"></a>标号的三个属性</h5><ol>
<li>段属性 <code>SEG</code></li>
</ol>
<p>它表示该标号所代表的地址在哪个逻辑段中，即段基值。</p>
<ol start="2">
<li>偏移量属性 <code>OFFSET</code></li>
</ol>
<p>它表示该标号所代表的地址在段内与段起点间的字节数，即地址的偏移量。</p>
<ol start="3">
<li>距离属性（也叫类型属性）</li>
</ol>
<p>它表示该标号可以被段内还是段间的指令调用。</p>
<ul>
<li><code>NEAR</code>（近）：用作段内转移，即只能是与该标号所指指令同在一个逻辑段的其它指令才能使用它</li>
<li><code>FAR</code>（远）：可以被非本段的转移和调用指令使用</li>
</ul>
<p>标号的距离属性可以有两种方法来指定：</p>
<p>(1) 隐含方式</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">SUB1:</span> <span class="keyword">MOV</span>  <span class="built_in">AX</span>, <span class="number">30H</span></span><br></pre></td></tr></table></figure>

<p><code>SUB1</code> 默认为 NEAR。</p>
<p>(2) 用 <code>LABEL</code> 伪指令给标号指定距离属性</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标号名 LABEL <span class="built_in">NEAR</span>/<span class="built_in">FAR</span></span><br></pre></td></tr></table></figure>

<p>该语句要与指令语句连用，如下：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">SUB1_FAR LABEL</span> <span class="built_in">FAR</span></span><br><span class="line"><span class="symbol">SUB1:</span> <span class="keyword">MOV</span>  <span class="built_in">AX</span>, <span class="number">30H</span></span><br></pre></td></tr></table></figure>

<p>上文中，<code>SUB1_FAR</code> 与 <code>SUB1</code> 两个标号具有相同的逻辑地址。但 <code>SUB1</code> 只能被本段调用，<code>SUB1_FAR</code> 可以被其它段的指令调用。</p>
<h5 id="LABEL-定义变量属性"><a href="#LABEL-定义变量属性" class="headerlink" title="LABEL 定义变量属性"></a>LABEL 定义变量属性</h5><p><code>LABEL</code> 伪指令还可以用于定义变量的属性，即改变一个变量的属性，如把字变量的高低字节作为字节变量来处理。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">DATA_BYTE  LABEL</span>  <span class="built_in">BYTE</span></span><br><span class="line">DATA_WORD  <span class="built_in">DW</span>  <span class="number">20H</span>  DUP(?)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>DATA_BYTE</code> 与 <code>DATA_WORD</code> 具有相同的段基址和偏移量</li>
<li><code>DATA_BYTE</code> 可以被用来存取一个字节数据，而 <code>DATA_WORD</code> 则不能</li>
</ul>
<h3 id="符号定义语句"><a href="#符号定义语句" class="headerlink" title="符号定义语句"></a>符号定义语句</h3><p>符号定义语句将常数或表达式等形式用某个指定的符号来表示。在 8086/8088 汇编语言中有两种符号定义语句，分别为等值语句 <code>EQU</code> 和等号语句 <code>=</code>。</p>
<h4 id="等值语句-EQU"><a href="#等值语句-EQU" class="headerlink" title="等值语句 EQU"></a>等值语句 EQU</h4><ul>
<li>格式：<code>符号名   EQU   表达式</code>  </li>
<li>功能：用符号名来表示 <code>EQU</code> 右边的表达式。后面的程序中一旦出现该符号名，汇编程序将把它替换成该表达式。  </li>
<li>表达式：</li>
</ul>
<ol>
<li>常数或数值表达式</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COUNT  <span class="built_in">EQU</span>  <span class="number">5</span></span><br><span class="line">NUM    <span class="built_in">EQU</span>  COUNT+<span class="number">5</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>地址表达式</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADR1   <span class="built_in">EQU</span>  <span class="built_in">DS</span>:[<span class="built_in">BP</span>+<span class="number">14</span>]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>变量名、寄存器名或指令助记符</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREG  <span class="built_in">EQU</span>  <span class="built_in">CX</span>   <span class="comment">; 在后面的程序使用CREG就是使用CX</span></span><br><span class="line">CBD   <span class="built_in">EQU</span>  <span class="keyword">DAA</span>  <span class="comment">; DAA为十进制调整指令</span></span><br></pre></td></tr></table></figure>

<p>注意，同一符号不能用 <code>EQU</code> 重复定义。</p>
<h4 id="等号语句"><a href="#等号语句" class="headerlink" title="等号语句 ="></a>等号语句 =</h4><p>格式：<code>符号名=表达式</code></p>
<p>等号语句与等值语句具有类似的作用，二者的区别是：</p>
<ul>
<li>等号语句可以对一个符号进行多次定义</li>
<li>等号语句不能为助记符定义别名（诸如 <code>CBD=DAA</code> 是错误的）</li>
</ul>
<p>等值语句与等号语句都不会为符号分配存储单元。所定义的符号没有段、偏离量和类型等属性。</p>
<h3 id="表达式与运算符"><a href="#表达式与运算符" class="headerlink" title="表达式与运算符"></a>表达式与运算符</h3><p>表达式是指令或伪指令语句操作数的常见形式。它由常数、变量、标号等通过操作运算符连接而成。</p>
<p><strong>任何表达式的值在程序被汇编的过程中进行计算确定，而不是到程序运行时才计算。</strong></p>
<p>8086/8088宏汇编语言中的操作运算符非常丰富，可以分为以下五类。</p>
<ul>
<li>算术运算符</li>
<li>逻辑运算符</li>
<li>关系运算符</li>
<li>数值返回运算符</li>
<li>属性修改运算符</li>
</ul>
<h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>包含 <code>+</code>、<code>-</code>、<code>*</code>、 <code>/</code> 、<code>MOD</code>、<code>SHL</code>、<code>SHR</code>、<code>[ ]</code>。</p>
<ol>
<li>运算符 <code>+</code> 和 <code>-</code> 也可作单目运算符，表示数的正负</li>
<li>使用 <code>+</code>、<code>-</code>、<code>*</code> 和 <code>/</code> 运算符时，参加运算的数和运算结果都是<strong>整数</strong></li>
<li><code>/</code> 运算为取商的整数部分，而 <code>MOD</code> 运算取除法运算的余数</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NUM=<span class="number">15</span>*<span class="number">8</span>       <span class="comment">; NUM = 120</span></span><br><span class="line">NUM=NUM/<span class="number">7</span>      <span class="comment">; NUM = 17</span></span><br><span class="line">NUM=NUM MOD <span class="number">3</span>  <span class="comment">; NUM = 2</span></span><br><span class="line">NUM=NUM+<span class="number">5</span>      <span class="comment">; NUM = 7</span></span><br><span class="line">NUM=-NUM-<span class="number">3</span>     <span class="comment">; NUM = -10</span></span><br><span class="line">NUM=-NUM-NUM   <span class="comment">; NUM = 20</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>SHR</code> 和 <code>SHL</code> 为逻辑移位运算符</li>
</ol>
<p><code>SHR</code> 为右移，左边移出来的空位用 0 补入。<br><code>SHL</code> 为左移，右边移出来的空位用 0 补入。</p>
<p>移位运算符（如上）与<a href="#算术左移-sal-逻辑左移-shl">移位指令</a>区别：</p>
<ul>
<li>移位运算符的操作对象是某一具体的数（<strong>常数</strong>），在汇编时完成移位操作</li>
<li>而移位指令是<strong>对一个寄存器或存储单元内容</strong>在程序运行时执行移位操作</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NUM=<span class="number">11011011B</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">AX</span>, NUM <span class="keyword">SHL</span> <span class="number">1</span>   <span class="comment">; AX=1 1011 0110B</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">BX</span>, NUM <span class="keyword">SHR</span> <span class="number">2</span>   <span class="comment">; BX= 11 0110B</span></span><br><span class="line"><span class="keyword">ADD</span>  <span class="built_in">DX</span>, NUM <span class="keyword">SHR</span> <span class="number">6</span>   <span class="comment">; DX = 11B</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>下标运算符 <code>[ ]</code> 具有相加的作用</li>
</ol>
<p><code>MOV  AX，DA_WORD[20H]</code> 等价于 <code>MOV  AX，DA_WORD+20H</code>。</p>
<p>以下语句均等价：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span>  <span class="built_in">AX</span>, ARRAY[<span class="built_in">BX</span>][<span class="built_in">SI</span>]  <span class="comment">; 基址变址寻址</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">AX</span>, ARRAY[<span class="built_in">BX</span>+<span class="built_in">SI</span>]</span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">AX</span>, [ARRAY+<span class="built_in">BX</span>][<span class="built_in">SI</span>]</span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">AX</span>, [ARRAY+<span class="built_in">SI</span>][<span class="built_in">BX</span>]</span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">AX</span>, [ARRAY+<span class="built_in">BX</span>+<span class="built_in">SI</span>]</span><br></pre></td></tr></table></figure>

<p>以下为错误语句：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span>  <span class="built_in">AX</span>，ARRAY+<span class="built_in">BX</span>+<span class="built_in">SI</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">AX</span>，ARRAY+<span class="built_in">BX</span>[<span class="built_in">SI</span>]</span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">AX</span>，ARRAY+DA_WORD</span><br></pre></td></tr></table></figure>

<h4 id="逻辑运"><a href="#逻辑运" class="headerlink" title="逻辑运"></a>逻辑运</h4><p>逻辑运算符有NOT、AND、OR和XOR等四个，它们执行的都是按位逻辑运算。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span>  <span class="built_in">AX</span>，<span class="keyword">NOT</span> <span class="number">0F0H</span>       <span class="comment">; 0FF0FH</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">AL</span>, <span class="keyword">NOT</span> <span class="number">0F0H</span>       <span class="comment">; 0FH</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">BL</span>, <span class="number">55H</span> <span class="keyword">AND</span> <span class="number">0F0H</span>   <span class="comment">; 50H</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="number">BH</span>, <span class="number">55H</span> <span class="keyword">OR</span> <span class="number">0F0H</span>    <span class="comment">; 0F5H</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">CL</span>, <span class="number">55H</span> <span class="keyword">XOR</span> <span class="number">0F0H</span>   <span class="comment">; 0A5H</span></span><br></pre></td></tr></table></figure>

<h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><ul>
<li>关系运算符包括：<code>EQ</code>（等于）、<code>NE</code>（不等于）、<code>LT</code>（小于，less than）、 <code>LE</code>（小于等于）、<code>GT</code>（大于）、 <code>GE</code>（大于等于）</li>
<li>关系运算符用来比较两个表达式的大小。比较的两个表达式必须同为<strong>常数</strong>或<strong>同一逻辑段中的变量</strong></li>
<li>若是常量的比较，则按<strong>无符号数</strong>进行比较；若是变量的比较，则比较它们的<strong>偏移量</strong>的大小。</li>
<li>关系运算的结果只能是<code>真</code>（<strong>全 1</strong>）或<code>假</code>（<strong>全 0</strong>）</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span>  <span class="built_in">AX</span>，<span class="number">0FH</span> EQ <span class="number">1111B</span>  <span class="comment">; AX = 0FFFF</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">BX</span>, <span class="number">0FH</span> NE <span class="number">1111B</span>  <span class="comment">; BX = 0</span></span><br><span class="line"></span><br><span class="line">VAR  <span class="built_in">DW</span> NUM LT <span class="number">0ABH</span>    <span class="comment">; 若符号常量 NUM 值小于 0ABH，则 DW=0FFFFH；否则为 0</span></span><br></pre></td></tr></table></figure>

<h4 id="数值返回运算符"><a href="#数值返回运算符" class="headerlink" title="数值返回运算符"></a>数值返回运算符</h4><p>该类运算符有 5 个，它们将变量或标号的某些特征值或存储单元地址的一部分提取出来。</p>
<h5 id="SEG-运算符"><a href="#SEG-运算符" class="headerlink" title="SEG 运算符"></a>SEG 运算符</h5><p>取变量或标号所在段的段基址。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 设 DATA 逻辑段段基址为 1FFEH</span></span><br><span class="line">DATA  <span class="meta">SEGMENT</span></span><br><span class="line"><span class="built_in">K1</span>  <span class="built_in">DW</span>  <span class="number">1</span>，<span class="number">2</span></span><br><span class="line"><span class="built_in">K2</span>  <span class="built_in">DW</span>  <span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">AX</span>, <span class="built_in">SEG</span>  <span class="built_in">K1</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">BX</span>, <span class="built_in">SEG</span>  <span class="built_in">K2</span></span><br></pre></td></tr></table></figure>

<p>两条 MOV 指令将被汇编为：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span>  <span class="built_in">AX</span>, <span class="number">1FFEH</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">BX</span>, <span class="number">1FFEH</span></span><br></pre></td></tr></table></figure>

<h5 id="OFFSET-运算符"><a href="#OFFSET-运算符" class="headerlink" title="OFFSET 运算符"></a>OFFSET 运算符</h5><p>该运算符的作用是取变量或标号在段内的偏移地址。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DATA <span class="meta">SEGMENT</span></span><br><span class="line">VAR1  <span class="built_in">DB</span>  <span class="number">20H</span> DUP(<span class="number">0</span>)</span><br><span class="line">VAR2  <span class="built_in">DW</span>  <span class="number">5A49H</span></span><br><span class="line">ADDR  <span class="built_in">DW</span>  VAR2         <span class="comment">; ADDR=20H</span></span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">BX</span>，VAR2          <span class="comment">; BX=5A49H</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">SI</span>, OFFSET VAR2   <span class="comment">; SI=20H</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">DI</span>, ADDR          <span class="comment">; DI=20H</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">BP</span>，OFFSET ADDR   <span class="comment">; BP=22H</span></span><br></pre></td></tr></table></figure>

<p>获取变量的偏移量还可以用指令 <code>LEA</code>。</p>
<p>需要注意的是：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">SI</span>, OFFSET DATA[<span class="built_in">BX</span>]</span><br><span class="line"><span class="comment">; 错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LEA</span> <span class="built_in">SI</span>, DATA[<span class="built_in">BX</span>]</span><br><span class="line"><span class="comment">; 正确</span></span><br></pre></td></tr></table></figure>

<h5 id="TYPE-运算符"><a href="#TYPE-运算符" class="headerlink" title="TYPE 运算符"></a>TYPE 运算符</h5><p>作用：取变量或标号的类型属性，并用数字形式表示。对变量来说就是取它的字节长度。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>BYTE</td>
<td>1</td>
</tr>
<tr>
<td>WORD</td>
<td>2</td>
</tr>
<tr>
<td>DWORD</td>
<td>4</td>
</tr>
<tr>
<td>QWORD</td>
<td>8</td>
</tr>
<tr>
<td>TBYTE</td>
<td>10</td>
</tr>
<tr>
<td>NEAR 标号</td>
<td>-1</td>
</tr>
<tr>
<td>FAR 标号</td>
<td>-2</td>
</tr>
</tbody></table>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">V1   <span class="built_in">DB</span>   <span class="string">'ABCDE'</span></span><br><span class="line">V2   <span class="built_in">DW</span>   <span class="number">1234H</span>, <span class="number">5678H</span></span><br><span class="line">V3   <span class="built_in">DD</span>   V2   </span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">AL</span>,  TYPE  V1     <span class="comment">; AL = 1</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">CL</span>,  TYPE  V2     <span class="comment">; CL = 2</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="number">CH</span>,  TYPE  V3     <span class="comment">; CH = 4</span></span><br></pre></td></tr></table></figure>

<h5 id="LENGTH-运算符"><a href="#LENGTH-运算符" class="headerlink" title="LENGTH 运算符"></a>LENGTH 运算符</h5><ul>
<li>该运算符用于取变量的长度</li>
<li>如果变量是用重复数据操作符 <code>DUP</code> 说明的,则 <code>LENGTH</code> 运算取<strong>最外层 DUP</strong>的重复值。</li>
<li>如果没有用 <code>DUP</code> 说明，则 <code>LENGTH</code> 运算返回值<strong>总是 1</strong>。</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">K1</span>  <span class="built_in">DB</span>   <span class="number">10H</span> DUP(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">K2</span>  <span class="built_in">DB</span>   <span class="number">10H</span>，<span class="number">20H</span>，<span class="number">30H</span>，<span class="number">40H</span></span><br><span class="line"><span class="built_in">K3</span>  <span class="built_in">DW</span>   <span class="number">20H</span> DUP (<span class="number">0</span>，<span class="number">1</span>，<span class="number">2</span> DUP(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">K4</span>  <span class="built_in">DB</span>   <span class="string">'ABCDEFGH'</span></span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">AL</span>,  LENGTH   <span class="built_in">K1</span>   <span class="comment">; (AL)=10H</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">BL</span>,  LENGTH   <span class="built_in">K2</span>   <span class="comment">; (BL)=1</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">CX</span>,  LENGTH   <span class="built_in">K3</span>   <span class="comment">; (CX)=20H</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">DX</span>,  LENGTH   <span class="built_in">K4</span>   <span class="comment">; (DX)=1</span></span><br></pre></td></tr></table></figure>

<h5 id="SIZE-运算符"><a href="#SIZE-运算符" class="headerlink" title="SIZE 运算符"></a>SIZE 运算符</h5><ul>
<li>该运算符只能用于变量</li>
<li><strong>SIZE = LENGTH * TYPE</strong></li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span>  <span class="built_in">AL</span>，SIZE  <span class="built_in">K1</span>     <span class="comment">; (AL)=10H</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">BL</span>，SIZE  <span class="built_in">K2</span>     <span class="comment">; (BL)=1</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">CL</span>，SIZE  <span class="built_in">K3</span>     <span class="comment">; (CL)=20H*2=40H</span></span><br><span class="line"><span class="keyword">MOV</span>  <span class="built_in">DL</span>，SIZE  <span class="built_in">K4</span>     <span class="comment">; (DL)=1</span></span><br></pre></td></tr></table></figure>

<h4 id="属性修改运算符"><a href="#属性修改运算符" class="headerlink" title="属性修改运算符"></a>属性修改运算符</h4><p>这一类运算符用来对变量、标号或存储器操作数的类型属性进行修改或指定。</p>
<h5 id="PTR-运算符"><a href="#PTR-运算符" class="headerlink" title="PTR 运算符"></a>PTR 运算符</h5><ul>
<li>格式：<code>类型   PTR   地址表达式</code></li>
<li>作用: 将地址表达式所指定的标号、变量或用其它形式表示的存储器地址的类型属性<strong>临时</strong>修改为 “类型”所指的值</li>
<li></li>
</ul>
<h5 id="HIGH-LOW"><a href="#HIGH-LOW" class="headerlink" title="HIGH/LOW"></a>HIGH/LOW</h5><p>用于分离表达式</p>
<h4 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h4><h3 id="程序的段结构"><a href="#程序的段结构" class="headerlink" title="程序的段结构"></a>程序的段结构</h3><h4 id="段定义伪指令-SEGMENT"><a href="#段定义伪指令-SEGMENT" class="headerlink" title="段定义伪指令 SEGMENT"></a>段定义伪指令 SEGMENT</h4><h5 id="段名"><a href="#段名" class="headerlink" title="段名"></a>段名</h5><h5 id="定位类型"><a href="#定位类型" class="headerlink" title="定位类型"></a>定位类型</h5><h5 id="组合类型"><a href="#组合类型" class="headerlink" title="组合类型"></a>组合类型</h5><h5 id="类别名"><a href="#类别名" class="headerlink" title="类别名"></a>类别名</h5><h4 id="段寻址伪指令-ASSUME"><a href="#段寻址伪指令-ASSUME" class="headerlink" title="段寻址伪指令 ASSUME"></a>段寻址伪指令 ASSUME</h4><h4 id="段寄存器的装入"><a href="#段寄存器的装入" class="headerlink" title="段寄存器的装入"></a>段寄存器的装入</h4><h3 id="过程定义伪指令-PROC"><a href="#过程定义伪指令-PROC" class="headerlink" title="过程定义伪指令 PROC"></a>过程定义伪指令 PROC</h3><h3 id="当前位置计数器-与定位伪指令-ORG"><a href="#当前位置计数器-与定位伪指令-ORG" class="headerlink" title="当前位置计数器 $ 与定位伪指令 ORG"></a>当前位置计数器 $ 与定位伪指令 ORG</h3>
        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2020-10-27T16:11:05.482Z" itemprop="dateUpdated">2020-10-27 16:11:05</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="https://blog.lyh543.cn">
            <img src="/img/avatar.png" alt="lyh543">
            lyh543
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/汇编语言/">汇编语言</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算机科学/">计算机科学</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/课程笔记/">课程笔记</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://blog.lyh543.cn/computer-science/assembly-language-and-interface-technology-of-microcomputer-classnote/&title=《汇编语言与微机接口技术 课程笔记》 — 小灰灰灰灰的博客&pic=https://blog.lyh543.cn/img/avatar.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://blog.lyh543.cn/computer-science/assembly-language-and-interface-technology-of-microcomputer-classnote/&title=《汇编语言与微机接口技术 课程笔记》 — 小灰灰灰灰的博客&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://blog.lyh543.cn/computer-science/assembly-language-and-interface-technology-of-microcomputer-classnote/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《汇编语言与微机接口技术 课程笔记》 — 小灰灰灰灰的博客&url=https://blog.lyh543.cn/computer-science/assembly-language-and-interface-technology-of-microcomputer-classnote/&via=https://blog.lyh543.cn" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://blog.lyh543.cn/computer-science/assembly-language-and-interface-technology-of-microcomputer-classnote/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/development/restful-api-standard/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">RESTful API 标准</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/computer-science/operating-system-classnote/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">操作系统 课程笔记</h4>
      </a>
    </div>
  
</nav>



    

















<section class="comments" id="comments">
    <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>
        var id = location.pathname
        if (location.pathname.length > 50) {
          id = location.pathname.replace(/\/\d+\/\d+\/\d+\//, '').replace('/', '').substring(0, 50)
        }
        const gitalk = new Gitalk({
          clientID: 'ec7daa4e047c3c30570d',
          clientSecret: '025a9e40a1d101f28fd1a945d286a819e9fa1c3d',
          repo: 'lyh543.github.io',
          owner: 'lyh543',
          admin: ['lyh543'],
          id: id,      // Ensure uniqueness and length less than 50
          title: document.title.split('|')[0],
          distractionFreeMode: false  // Facebook-like distraction free mode
        })

        gitalk.render('gitalk-container')
    </script>
</section>




</article>



</div>

        <footer class="footer">
    <div class="top">
        

        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>lyh543 &copy; 2019 - 2020</span>
            <span>
                
                <a href="http://www.miitbeian.gov.cn/" target="_blank">蜀ICP备19034464号</a><br>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://blog.lyh543.cn/computer-science/assembly-language-and-interface-technology-of-microcomputer-classnote/&title=《汇编语言与微机接口技术 课程笔记》 — 小灰灰灰灰的博客&pic=https://blog.lyh543.cn/img/avatar.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://blog.lyh543.cn/computer-science/assembly-language-and-interface-technology-of-microcomputer-classnote/&title=《汇编语言与微机接口技术 课程笔记》 — 小灰灰灰灰的博客&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://blog.lyh543.cn/computer-science/assembly-language-and-interface-technology-of-microcomputer-classnote/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《汇编语言与微机接口技术 课程笔记》 — 小灰灰灰灰的博客&url=https://blog.lyh543.cn/computer-science/assembly-language-and-interface-technology-of-microcomputer-classnote/&via=https://blog.lyh543.cn" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://blog.lyh543.cn/computer-science/assembly-language-and-interface-technology-of-microcomputer-classnote/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQ4AAAEOCAAAAABd2qZ5AAAD4ElEQVR42u3aSW7CQBAFUO5/aSJlFQns/BpsFOV5hQC3ux+LoobHI76e39fP1z/fOfrO66ev759/5/lynd91voe1CwcOHDhwBEc9uvKlk3vPEc9Rqk85v+uQGAcOHDhwLHEkwbW69PnW81Cd/DAJx/ldOHDgwIHjfo4kGFdTteT71SSzh4gDBw4cOO7nSGgKDy4erFc0xIEDBw4cn+KoBtEkDcsTuV46d8X+ceDAgQPHnKM30PC3Xl8+34EDBw4cOOJkbFIW3LqrOqbQOx0OHDhw4JhznI8XJPHozn8BVZrqcAMOHDhw4LiHY1Lay4cbqo2o5N5mwREHDhw4cIw5qtvqpV55REsCeb5mfi8OHDhw4Nji6KVGvRCYjy/s7iRP8HDgwIEDxxbHPCVLAm1yjOqIW7Ug+MtfARw4cODAMeCoPjhPonolwmr610vecODAgQPHdRy9smDClyP2in3VMYVCSokDBw4cOAYcvbJgns71BiaqV2+g4c37OHDgwIHjMo68YNcLohOs+Z+Aw5IlDhw4cOAYc0xGAaKOVqsp1WsjVdtah8Q4cODAgWPA0UuQqkMPeSCsrrZLiQMHDhw45hyTIl0+6Janc9XGUjWpy9tROHDgwIGjx5G3cPJBh+T71fWr4bm5cxw4cODAscRxxVDafDAiOVi+kygk48CBAweOVY68nVNN0vIgmreRkpSsmcLhwIEDB44xR7XxMxl3uLpN1RuhwIEDBw4cWxy9Ml9v3KGamH1qfRw4cODAcQVHL4hOgl/SaqqunAf+NzvBgQMHDhxLHEkpbYupeuze0F4vQcWBAwcOHFdwJEE3L9hVBxd6hcXkLNFTcODAgQNHiyO/bYtpgp4X+6ptKhw4cODAscWRhMB8od7rKtwjvnpBGgcOHDhw7HLkJcJqKlU9ZK8IWMXCgQMHDhy7HMkSScislgInofeKH+xNRosDBw4cOFbbTtVF85CWFxPngxE5JQ4cOHDg2OKotnMWSm+t9Cz5NN//IRMOHDhw4Fji6G2uF553U7hqTe+Xe3HgwIEDxxJHvkT1YPPgNxl6q5YOceDAgQPHnKMawHoDcL2g2GuG9YqV9ZiMAwcOHDje7/BZvJL2z+SuHGhr/ag4iAMHDhw4Yo5qcLrz9W5Qz5+FAwcOHDjmHL3mUK8At3WY3UD+mPxrwIEDBw4cxaG33uDCZFtbcNXhBhw4cODA8SmOJMhVxwh6gwuTMH+4cxw4cODAcSNHTlBNus6BeuMXvbCNAwcOHDi2OJLi4NWJXI7eG8KISoQ4cODAgWPMMRloqAazHGX+E+Y/29p8Bw4cOHD8d44vy4nFB5CBkjQAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>








</body>
</html>
