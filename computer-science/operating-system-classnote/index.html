<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>操作系统 课程笔记 | 小灰灰灰灰的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="计算机科学,课程笔记,操作系统">
    <meta name="description" content="操作系统概述操作系统的目标和功能操作系统：  控制应用程序执行的程序 应用系统和计算机硬件之间的接口  目标：方便、有效、扩展能力 功能：  （作为用户/计算机接口的）OS 提供的服务： 程序开发 程序运行 I/O设备访问 文件访问控制 系统访问 错误检测和响应 记账 Accounting   （作为资源管理器的）操作系统负责 资源管理，控制数据的移动、存储、管理    操作系统的历史串行处理 无">
<meta name="keywords" content="计算机科学,课程笔记,操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统 课程笔记">
<meta property="og:url" content="https://blog.lyh543.cn/computer-science/operating-system-classnote/index.html">
<meta property="og:site_name" content="小灰灰灰灰的博客">
<meta property="og:description" content="操作系统概述操作系统的目标和功能操作系统：  控制应用程序执行的程序 应用系统和计算机硬件之间的接口  目标：方便、有效、扩展能力 功能：  （作为用户/计算机接口的）OS 提供的服务： 程序开发 程序运行 I/O设备访问 文件访问控制 系统访问 错误检测和响应 记账 Accounting   （作为资源管理器的）操作系统负责 资源管理，控制数据的移动、存储、管理    操作系统的历史串行处理 无">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/e42643e9fb50aeccb097341e0dcaa3029fb8758566fc841f2ba99df89ec3da3d.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/10ec395463fc37b60cdcc09abd1667f9dd0a9f359164323864ac10a2db96ff52.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/f6cdb2d37258d0428b3007658a9f9015f27a1803bb6e192a6e4d6d2d9f73b335.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/9222946462cd6101a92e4fb8e481601f498ba1c9c07afde2f9382df9bfc5152d.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/ea029a3ebaf6919b490b232767118719d941a4a30000332643101a781978d44b.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/f7da3a116faa505ad0632c9a57d81bd69e909d29b19cd1aced05042a5143e03e.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/e369dc4db527203b4d4c8031308e40a539372f1b31f3963dc921b3687aa7db2c.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/775f0c03288a2fb70482e0e18c3cd5efe02050e10273071b283b925e1c4d389a.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/91b7d7017b28f3c83e467190be1604282b540498dad5134a93f41493cb8c4d13.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/fe85f271b767ca86e4b154493f7cb0f354da2892642000abfdb928429fbe321e.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/de668abd9bc9d7c3d0f07b76b768bfa8f91b1e3275d7385d8d2930fbd799f100.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/3740fece581f214cb7edc5431a02a5107d0a75677b24f5303471285d9e332d8f.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/16f4abf3eaf38c3a612a2c504b544cdf5cdc8bb602001aeddada7e6b2fc89337.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/dd44338af4c33499f7c7ae41408036db934626e1c9bc9886360fba0d77504e8d.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/1aa7a23cbaebde3a10eaed151a557601867cc782591daff2e4ebb939f7b8dcf8.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/5c072002825672f047f542af8992172a7ab3a2ffb4a5b11088d2eccca0dd871d.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/3d673eb64b22f2459f6c4e5d9b9ac13b8aca70e505a5817266e10c9f249c0b17.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/ec439cb6c9d1ee4150f9068254d3a41a567018577184e643ed883609c788c465.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/40c97dc5b2edb605614fc76316da3e8eee5e78b0770e66b20288f763e0351b74.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/5511e243d259901289032791547d2a731bc613a177ef95b94c5c7431fc9334f1.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/98346f16297884d5a770f909fdf8ec6ed0c7ec9f525ea2cc1b176e44e8a2260c.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/e1e64fb637b2b627e7c59ab74602297000a3d101436c7d3e2817d346c1790dfc.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/d41f5a0daf9d2e9a104f41da70c9e9dd25d3d539fb2c6c7d87c707b1b5aaf1cb.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/52eaa607258e69c198ab6c4e40033add64cd587f4b94c934327b5cc60d476728.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/5e0d4e81502fd32090dc5bc0903b16c3a084a1459d2715a94a0f51ca4fe12ec1.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/1fa3ae807c84a1155891b41760a02678c0213adbe7747274b173c93c1ec79b88.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/fb6259090137f1b462f3985e993b822b64b63cff0aec0a38e579d29f7a9fcd7c.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/ddde0c35862ae06c5a019a286f2d1c36dc01285685570da3d68f951a4f16ebbb.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/1c01e23a1752eae3007999b4d1bc99ca977e01dd0f8bfd055c667d57648eae3b.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/c9c7e964cbd4db9b84ec977c862c66c5ac919780cf218c9f1dcb625d3674e302.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/d413ee8142e7bec16c3bc644d1c611d8c5447b212039cba415eb8fae3a04ec76.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/74b533c2ae6d3895a26d1cf9568acfba32b8110db32111fd6bf09e3de5638fb1.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/e8435fcc2d8c1c1ac0a9e29271b39ac9ac5a8a60779d8b90be3eba30d341919a.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/9c693880d13dd43e005a7e588af26c7291462a7e13d07c7d40dfb45f4ff34bae.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/b5d24596d24b0f853ea10751e0c16634169b6884e1ef48bdbf6ed2be7f4f7a39.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/e73c93ff19097507f860f0d0fd90db649ff848cd093afb4062390f4a904848d4.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/319d2b33cddf7eecb0e9797f6a5e7a1300273389770ed8104706b5ab850e05dd.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/276c846bfdc127bacb591e1224689d2460e8ce934c50f0d9e09800ab155c7077.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/8f3b60207781b74a7c41de935bb83508d4c6d9cbfae71c88208076fac3794440.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/544ae847b7d710680678853338fc26643b01aaae6aa24adcad89ee9c4acdb7a1.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/dbba9e70c56d6c0fc1bb029b5b7434d118ff6171db5cd6a7b0e2032acfb6a6e2.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/a4f9bec23de25af74ea9a242ede66e56daad3565dad29e43007372b52492c347.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/e2794f1eebb0563cc3b7451381a053d9f123ad6550fd31e67a268fb38a02d4c2.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/e2d616552ffc0ae85c84d1b6241dd3ff23b4a74b85519b55f44e484e570851e3.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/0ea56c428a5734629be630d7c9e98151782ee77d30c55d099ef5bd32fe20e70c.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/b830f9af056042c3b3fb157d6fac999b5d8dcc1c59e4bf792dc8c92046ea1a31.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/44fc51e62cc23ed7e5a337fbca7e62f66bc770aa0a4d4b1a5f9e63462020c674.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/0157b7d6af35892595f8dc7b2ad08c71e0204d59b2df82cc7a6ae3051c392c3a.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/d45dc487f6f1f948e555b7b454ffc4935c17eadfc3f7923b04a547f4a4c74e13.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/1a7ff7c009c0d8165fac407523fe185914a9afed82c08179c321bd174d940d59.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/f68c7064c7f8b900b53ae7be62e4650acc2fbb7d7dd7bc8624cc3b41af266cc4.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/2cd1fdcbdb7a4876225188fd354391649b3be6ef25ca8ebbf31f15a9b2dbd45e.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/189d229f6bff53861ede276608416ef5325b9ae153a04bcc564f69f8e16cafbb.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/9c1838f926b4f5176fcb7cac19ac6fabd5fcff7aa5099df3d27d7b7310ab0a74.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/40c1ab3af7398095bbc630ae8b35544533fb763af64e62b3ca1ee46430b257ca.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/0f09c62734fb10c414a49e7a627ad61f363a2bd9f092ea0b55fd8ec14f3e5954.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/aae5f0d87da23e977e16bd4f5bedb7e92a44258d8c57d8eb57f1719d1e013c0f.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/6ee2f2f43447dae9c57d0dc6df355bec0fc549695c1ee4a57240abbaa1f8d346.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/d95d46d4d66424e32e1c26e3fb74aa0cc5dc56548ea763618fea476cdc709456.png">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/d9393439dc3d0ca24039b39a80f0e3561ad8e1e89c5ec9cbe4147c40e9b8fc3e.gif">
<meta property="og:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/52496acccf6f98f76ff991478a120d1a6d454185437fe04df573452dc1836976.png">
<meta property="og:updated_time" content="2020-10-27T16:11:05.546Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="操作系统 课程笔记">
<meta name="twitter:description" content="操作系统概述操作系统的目标和功能操作系统：  控制应用程序执行的程序 应用系统和计算机硬件之间的接口  目标：方便、有效、扩展能力 功能：  （作为用户/计算机接口的）OS 提供的服务： 程序开发 程序运行 I/O设备访问 文件访问控制 系统访问 错误检测和响应 记账 Accounting   （作为资源管理器的）操作系统负责 资源管理，控制数据的移动、存储、管理    操作系统的历史串行处理 无">
<meta name="twitter:image" content="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/e42643e9fb50aeccb097341e0dcaa3029fb8758566fc841f2ba99df89ec3da3d.png">
    
        <link rel="alternate" type="application/atom+xml" title="小灰灰灰灰的博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.png">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu"  >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">lyh543</h5>
          <a href="mailto:lyh543@outlook.com" title="lyh543@outlook.com" class="mail">lyh543@outlook.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/lyh543" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">操作系统 课程笔记</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">操作系统 课程笔记</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-09-08T10:20:09.000Z" itemprop="datePublished" class="page-time">
  2020-09-08
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/计算机科学/">计算机科学</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#操作系统概述"><span class="post-toc-number">1.</span> <span class="post-toc-text">操作系统概述</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#操作系统的目标和功能"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">操作系统的目标和功能</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#操作系统的历史"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">操作系统的历史</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#串行处理"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">串行处理</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#简单批处理系统"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">简单批处理系统</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#多道批处理系统"><span class="post-toc-number">1.2.3.</span> <span class="post-toc-text">多道批处理系统</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#分时系统"><span class="post-toc-number">1.2.4.</span> <span class="post-toc-text">分时系统</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#实时系统"><span class="post-toc-number">1.2.5.</span> <span class="post-toc-text">实时系统</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#操作系统的主要成就"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">操作系统的主要成就</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#进程"><span class="post-toc-number">1.3.1.</span> <span class="post-toc-text">进程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#内存管理"><span class="post-toc-number">1.3.2.</span> <span class="post-toc-text">内存管理</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#信息保护和安全"><span class="post-toc-number">1.3.3.</span> <span class="post-toc-text">信息保护和安全</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#调度和资源管理"><span class="post-toc-number">1.3.4.</span> <span class="post-toc-text">调度和资源管理</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#现代操作系统的特征"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">现代操作系统的特征</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#容错性"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">容错性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#多处理器和多核操作系统考虑因素"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">多处理器和多核操作系统考虑因素</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#主流操作系统（略）"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">主流操作系统（略）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#单体内核"><span class="post-toc-number">1.7.1.</span> <span class="post-toc-text">单体内核</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#进程管理"><span class="post-toc-number">2.</span> <span class="post-toc-text">进程管理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#进程描述与控制"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">进程描述与控制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#什么是进程"><span class="post-toc-number">2.1.1.</span> <span class="post-toc-text">什么是进程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#进程状态"><span class="post-toc-number">2.1.2.</span> <span class="post-toc-text">进程状态</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#进程轨迹"><span class="post-toc-number">2.1.2.1.</span> <span class="post-toc-text">进程轨迹</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#进程的的两状态模型"><span class="post-toc-number">2.1.2.2.</span> <span class="post-toc-text">进程的的两状态模型</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#进程的创建和终止"><span class="post-toc-number">2.1.2.3.</span> <span class="post-toc-text">进程的创建和终止</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#进程的五状态模型"><span class="post-toc-number">2.1.2.4.</span> <span class="post-toc-text">进程的五状态模型</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#挂起"><span class="post-toc-number">2.1.2.5.</span> <span class="post-toc-text">挂起</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#进程描述"><span class="post-toc-number">2.1.3.</span> <span class="post-toc-text">进程描述</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#进程控制"><span class="post-toc-number">2.1.4.</span> <span class="post-toc-text">进程控制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#内核"><span class="post-toc-number">2.1.4.1.</span> <span class="post-toc-text">内核</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#执行模式"><span class="post-toc-number">2.1.4.2.</span> <span class="post-toc-text">执行模式</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#进程创建"><span class="post-toc-number">2.1.4.3.</span> <span class="post-toc-text">进程创建</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#进程切换"><span class="post-toc-number">2.1.4.4.</span> <span class="post-toc-text">进程切换</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#系统中断"><span class="post-toc-number">2.1.4.4.1.</span> <span class="post-toc-text">系统中断</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#模式切换"><span class="post-toc-number">2.1.4.4.2.</span> <span class="post-toc-text">模式切换</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#进程状态转换"><span class="post-toc-number">2.1.4.4.3.</span> <span class="post-toc-text">进程状态转换</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#操作系统的执行"><span class="post-toc-number">2.1.4.5.</span> <span class="post-toc-text">操作系统的执行</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Unix-SVR4-的进程管理"><span class="post-toc-number">2.1.5.</span> <span class="post-toc-text">Unix SVR4 的进程管理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#进程状态切换"><span class="post-toc-number">2.1.5.1.</span> <span class="post-toc-text">进程状态切换</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Unix-SVR4-的进程创建"><span class="post-toc-number">2.1.5.2.</span> <span class="post-toc-text">Unix SVR4 的进程创建</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#线程"><span class="post-toc-number">2.1.6.</span> <span class="post-toc-text">线程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#线程与进程"><span class="post-toc-number">2.1.6.1.</span> <span class="post-toc-text">线程与进程</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#线程分类"><span class="post-toc-number">2.1.6.2.</span> <span class="post-toc-text">线程分类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#用户级线程-ULT"><span class="post-toc-number">2.1.6.2.1.</span> <span class="post-toc-text">用户级线程 ULT</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#内核级线程-KLT"><span class="post-toc-number">2.1.6.2.2.</span> <span class="post-toc-text">内核级线程 KLT</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#混合方法"><span class="post-toc-number">2.1.6.2.3.</span> <span class="post-toc-text">混合方法</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#进程调度"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">进程调度</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#调度的类型"><span class="post-toc-number">2.2.1.</span> <span class="post-toc-text">调度的类型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#长程调度"><span class="post-toc-number">2.2.1.1.</span> <span class="post-toc-text">长程调度</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#中程调度"><span class="post-toc-number">2.2.1.2.</span> <span class="post-toc-text">中程调度</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#短程调度"><span class="post-toc-number">2.2.1.3.</span> <span class="post-toc-text">短程调度</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#调度的规则"><span class="post-toc-number">2.2.2.</span> <span class="post-toc-text">调度的规则</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#调度相关基本概念"><span class="post-toc-number">2.2.2.1.</span> <span class="post-toc-text">调度相关基本概念</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#调度规则总结"><span class="post-toc-number">2.2.2.2.</span> <span class="post-toc-text">调度规则总结</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#优先级的使用"><span class="post-toc-number">2.2.2.3.</span> <span class="post-toc-text">优先级的使用</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#调度的决策模式"><span class="post-toc-number">2.2.3.</span> <span class="post-toc-text">调度的决策模式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#调度算法"><span class="post-toc-number">2.2.4.</span> <span class="post-toc-text">调度算法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#概述"><span class="post-toc-number">2.2.4.1.</span> <span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#先来先服务-FCFS"><span class="post-toc-number">2.2.4.2.</span> <span class="post-toc-text">先来先服务 FCFS</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#时间片轮转-RR"><span class="post-toc-number">2.2.4.3.</span> <span class="post-toc-text">时间片轮转 RR</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#短进程优先-SPN"><span class="post-toc-number">2.2.4.4.</span> <span class="post-toc-text">短进程优先 SPN</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#剩余时间最短优先-SRT"><span class="post-toc-number">2.2.4.5.</span> <span class="post-toc-text">剩余时间最短优先 SRT</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#响应比高者优先-SRRN"><span class="post-toc-number">2.2.4.6.</span> <span class="post-toc-text">响应比高者优先 SRRN</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#反馈调度法-Feedback"><span class="post-toc-number">2.2.4.7.</span> <span class="post-toc-text">反馈调度法 Feedback</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#实时系统与实时调度"><span class="post-toc-number">2.2.5.</span> <span class="post-toc-text">实时系统与实时调度</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#分类"><span class="post-toc-number">2.2.5.1.</span> <span class="post-toc-text">分类</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#特点"><span class="post-toc-number">2.2.5.2.</span> <span class="post-toc-text">特点</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#实时调度的两个维度"><span class="post-toc-number">2.2.5.3.</span> <span class="post-toc-text">实时调度的两个维度</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#调度方法"><span class="post-toc-number">2.2.5.4.</span> <span class="post-toc-text">调度方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#静态表驱动调度表"><span class="post-toc-number">2.2.5.4.1.</span> <span class="post-toc-text">静态表驱动调度表</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#静态优先级抢占调度法"><span class="post-toc-number">2.2.5.4.2.</span> <span class="post-toc-text">静态优先级抢占调度法</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#基于动态规划的调度法"><span class="post-toc-number">2.2.5.4.3.</span> <span class="post-toc-text">基于动态规划的调度法</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#动态尽力调度法"><span class="post-toc-number">2.2.5.4.4.</span> <span class="post-toc-text">动态尽力调度法</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#抢占方式"><span class="post-toc-number">2.2.5.5.</span> <span class="post-toc-text">抢占方式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#基于时间片的轮转调度"><span class="post-toc-number">2.2.5.5.1.</span> <span class="post-toc-text">基于时间片的轮转调度</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#基于优先级的非抢占调度"><span class="post-toc-number">2.2.5.5.2.</span> <span class="post-toc-text">基于优先级的非抢占调度</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#基于优先级的抢占点抢占调度"><span class="post-toc-number">2.2.5.5.3.</span> <span class="post-toc-text">基于优先级的抢占点抢占调度</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#立即抢占式调度"><span class="post-toc-number">2.2.5.5.4.</span> <span class="post-toc-text">立即抢占式调度</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#实时调度示例"><span class="post-toc-number">2.2.5.6.</span> <span class="post-toc-text">实时调度示例</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#有完成限期的周期性实时任务"><span class="post-toc-number">2.2.5.6.1.</span> <span class="post-toc-text">有完成限期的周期性实时任务</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#有开始限期的非周期性实时任务"><span class="post-toc-number">2.2.5.6.2.</span> <span class="post-toc-text">有开始限期的非周期性实时任务</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#速率单调调度算法"><span class="post-toc-number">2.2.5.6.3.</span> <span class="post-toc-text">速率单调调度算法</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#实时系统处理能力限制"><span class="post-toc-number">2.2.5.7.</span> <span class="post-toc-text">实时系统处理能力限制</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#优先级反转"><span class="post-toc-number">2.2.5.8.</span> <span class="post-toc-text">优先级反转</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#进程同步"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">进程同步</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#并发的原理"><span class="post-toc-number">2.3.1.</span> <span class="post-toc-text">并发的原理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#相关概念"><span class="post-toc-number">2.3.1.1.</span> <span class="post-toc-text">相关概念</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#并发控制的产生"><span class="post-toc-number">2.3.1.2.</span> <span class="post-toc-text">并发控制的产生</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#进程间的交互方式"><span class="post-toc-number">2.3.1.3.</span> <span class="post-toc-text">进程间的交互方式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#进程间的竞争资源"><span class="post-toc-number">2.3.1.3.1.</span> <span class="post-toc-text">进程间的竞争资源</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#进程间通过共享合作"><span class="post-toc-number">2.3.1.3.2.</span> <span class="post-toc-text">进程间通过共享合作</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#进程间通过通信合作"><span class="post-toc-number">2.3.1.3.3.</span> <span class="post-toc-text">进程间通过通信合作</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#互斥"><span class="post-toc-number">2.3.2.</span> <span class="post-toc-text">互斥</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#互斥：软件方法"><span class="post-toc-number">2.3.2.1.</span> <span class="post-toc-text">互斥：软件方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#初步设想——轮换使用临界区"><span class="post-toc-number">2.3.2.1.1.</span> <span class="post-toc-text">初步设想——轮换使用临界区</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#第一次改进——设置临界区状态标志"><span class="post-toc-number">2.3.2.1.2.</span> <span class="post-toc-text">第一次改进——设置临界区状态标志</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#信号量"><span class="post-toc-number">2.3.3.</span> <span class="post-toc-text">信号量</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#生产者-消费者问题"><span class="post-toc-number">2.3.4.</span> <span class="post-toc-text">生产者/消费者问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#示例一"><span class="post-toc-number">2.3.4.1.</span> <span class="post-toc-text">示例一</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#示例三"><span class="post-toc-number">2.3.4.2.</span> <span class="post-toc-text">示例三</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#示例四"><span class="post-toc-number">2.3.4.3.</span> <span class="post-toc-text">示例四</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#读者-写者问题"><span class="post-toc-number">2.3.5.</span> <span class="post-toc-text">读者/写者问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#读者优先"><span class="post-toc-number">2.3.5.1.</span> <span class="post-toc-text">读者优先</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#公平优先"><span class="post-toc-number">2.3.5.2.</span> <span class="post-toc-text">公平优先</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#写者优先"><span class="post-toc-number">2.3.5.3.</span> <span class="post-toc-text">写者优先</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#写者优先改进"><span class="post-toc-number">2.3.5.4.</span> <span class="post-toc-text">写者优先改进</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#示例一-1"><span class="post-toc-number">2.3.5.5.</span> <span class="post-toc-text">示例一</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#示例二"><span class="post-toc-number">2.3.5.6.</span> <span class="post-toc-text">示例二</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#理发师睡觉问题"><span class="post-toc-number">2.3.6.</span> <span class="post-toc-text">理发师睡觉问题</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#管程"><span class="post-toc-number">2.3.7.</span> <span class="post-toc-text">管程</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#进程死锁"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">进程死锁</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#内存管理-1"><span class="post-toc-number">3.</span> <span class="post-toc-text">内存管理</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#I-O-管理与磁盘调度"><span class="post-toc-number">4.</span> <span class="post-toc-text">I/O 管理与磁盘调度</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#文件系统"><span class="post-toc-number">5.</span> <span class="post-toc-text">文件系统</span></a></li></ol>
        </nav>
    </aside>


<article id="post-computer-science/operating-system-classnote"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">操作系统 课程笔记</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-09-08 10:20:09" datetime="2020-09-08T10:20:09.000Z"  itemprop="datePublished">2020-09-08</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/计算机科学/">计算机科学</a></li></ul>



            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h2><h3 id="操作系统的目标和功能"><a href="#操作系统的目标和功能" class="headerlink" title="操作系统的目标和功能"></a>操作系统的目标和功能</h3><p>操作系统：</p>
<ul>
<li>控制应用程序执行的<strong>程序</strong></li>
<li>应用系统和计算机硬件之间的<strong>接口</strong></li>
</ul>
<p>目标：方便、有效、扩展能力</p>
<p>功能：</p>
<ul>
<li>（作为用户/计算机接口的）OS 提供的服务：<ul>
<li>程序开发</li>
<li>程序运行</li>
<li>I/O设备访问</li>
<li>文件访问控制</li>
<li>系统访问</li>
<li>错误检测和响应</li>
<li>记账 <code>Accounting</code></li>
</ul>
</li>
<li>（作为资源管理器的）操作系统负责<ul>
<li>资源管理，控制数据的移动、存储、管理</li>
</ul>
</li>
</ul>
<h3 id="操作系统的历史"><a href="#操作系统的历史" class="headerlink" title="操作系统的历史"></a>操作系统的历史</h3><h4 id="串行处理"><a href="#串行处理" class="headerlink" title="串行处理"></a>串行处理</h4><ul>
<li>无 OS</li>
<li>控制台、输入设备（卡片机阅读器）</li>
</ul>
<h4 id="简单批处理系统"><a href="#简单批处理系统" class="headerlink" title="简单批处理系统"></a>简单批处理系统</h4><ul>
<li>监控程序</li>
<li>对一批作业自动处理</li>
<li>内存中只能存放一道作业</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/e42643e9fb50aeccb097341e0dcaa3029fb8758566fc841f2ba99df89ec3da3d.png" alt="简单批处理系统" title>
                </div>
                <div class="image-caption">简单批处理系统</div>
            </figure>

<p>监控程序的功能：</p>
<ul>
<li>作业的自动续接</li>
<li>内存保护</li>
<li>定时器（防止作业独占）</li>
<li>特权指令（内核模式下）</li>
<li>中断</li>
</ul>
<p>运行模式：用户模式、内核模式</p>
<h4 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/10ec395463fc37b60cdcc09abd1667f9dd0a9f359164323864ac10a2db96ff52.png" alt="多道批处理系统" title>
                </div>
                <div class="image-caption">多道批处理系统</div>
            </figure>

<p>多道批处理系统：简单批处理系统的改进</p>
<ul>
<li>内存中同时存放多个作业</li>
<li>作业可并发执行</li>
<li>作业调度程序</li>
</ul>
<p>硬件支持：</p>
<ul>
<li>I/O中断</li>
<li>DMA</li>
<li>……</li>
</ul>
<p>特征：<strong>多道性、调度性、无序性、无交互能力</strong></p>
<p>如下，系统可用内存250MB，三个作业可同时处理：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/f6cdb2d37258d0428b3007658a9f9015f27a1803bb6e192a6e4d6d2d9f73b335.png" alt="示例-信息" title>
                </div>
                <div class="image-caption">示例-信息</div>
            </figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/9222946462cd6101a92e4fb8e481601f498ba1c9c07afde2f9382df9bfc5152d.png" alt="示例-实现" title>
                </div>
                <div class="image-caption">示例-实现</div>
            </figure>

<h4 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h4><p>产生原因：人机交互、共享主机、方便上机</p>
<p>分时系统：</p>
<ul>
<li>采用多道程序设计技术处理多个交互作业</li>
<li>多个用户共享处理器</li>
<li>多个用户通过不同终端同时访问系统</li>
</ul>
<p>特征：<strong>多路性、独立性、及时性、交互性</strong></p>
<table>
<thead>
<tr>
<th>比较</th>
<th>多道批处理系统</th>
<th>分时</th>
</tr>
</thead>
<tbody><tr>
<td>主要目标</td>
<td>充分利用处理器</td>
<td>减少响应时间</td>
</tr>
<tr>
<td>OS 指令源</td>
<td>作业提供命令（无交互）</td>
<td>终端键入命令（来自用户）</td>
</tr>
</tbody></table>
<p>第一个分时操作系统：CTSS (Compatible Time-Sharing System)</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/ea029a3ebaf6919b490b232767118719d941a4a30000332643101a781978d44b.png" alt="CTSS 内存占用示例" title>
                </div>
                <div class="image-caption">CTSS 内存占用示例</div>
            </figure>

<h4 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h4><p>系统能够<strong>及时（即时）</strong>响应外部事件的请求，在规定的时间内开始或完成对该事件的处理，并控制所有实时任务协调一致地运行。</p>
<p>应用领域：</p>
<ul>
<li>航空航天</li>
<li>军事</li>
<li>工业控制</li>
<li>事务系统<br><del>总之日常使用不需要</del></li>
</ul>
<p>特征：可确定性、可响应性、用户控制、可靠性、故障弱化能力</p>
<h3 id="操作系统的主要成就"><a href="#操作系统的主要成就" class="headerlink" title="操作系统的主要成就"></a>操作系统的主要成就</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>进程：一个正在处理器执行的程序</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/f7da3a116faa505ad0632c9a57d81bd69e909d29b19cd1aced05042a5143e03e.png" alt="为什么会有进程" title>
                </div>
                <div class="image-caption">为什么会有进程</div>
            </figure>  

<p>进程的组成：</p>
<ul>
<li>可执行程序</li>
<li>相关数据</li>
<li>程序的执行上下文（execution context）<ul>
<li>进程状态</li>
<li>操作系统用来管理和控制进程所需的所有数据（处理器寄存器的内容、进程优先级、是否在等待I/O事件、在内存中的位置……）</li>
</ul>
</li>
</ul>
<p>如下，正在执行的 B 进程切换到 A 时，需要保存 B 的上下文：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/e369dc4db527203b4d4c8031308e40a539372f1b31f3963dc921b3687aa7db2c.png" alt="典型的进程实现" title>
                </div>
                <div class="image-caption">典型的进程实现</div>
            </figure>

<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>任务：</p>
<ul>
<li>进程隔离</li>
<li>自动分配和管理</li>
<li>支持模块化程序设计</li>
<li>保护和访问控制</li>
<li>长期存储</li>
</ul>
<p>文件系统：实现了长期存储<br>文件：一个有名称的对象，访问控制和保护的基本单元</p>
<p>虚拟存储：</p>
<ul>
<li>以逻辑方式访问存储器，不考虑物理内存可用的空间数量</li>
<li>满足多作业F同时驻留内存的要求</li>
<li>换入、换出机制</li>
<li>分页机制（进程大小不同）</li>
<li>每个作业部分驻留（检测到缺页时载入）</li>
</ul>
<p>分页机制：</p>
<ul>
<li>页：若干个固定大小的块，组成进程</li>
<li><strong>虚地址</strong>（virtual address）：由页号和页内偏移量组成</li>
<li>虚地址和内存中<strong>实地址</strong>（real address，物理地址）之间的动态映射机制</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/775f0c03288a2fb70482e0e18c3cd5efe02050e10273071b283b925e1c4d389a.png" alt="虚存寻址" title>
                </div>
                <div class="image-caption">虚存寻址</div>
            </figure>

<h4 id="信息保护和安全"><a href="#信息保护和安全" class="headerlink" title="信息保护和安全"></a>信息保护和安全</h4><p>OS 的 4 类典型安全问题：</p>
<ul>
<li>可用性</li>
<li>保密性</li>
<li>数据完整性</li>
<li>认证</li>
</ul>
<h4 id="调度和资源管理"><a href="#调度和资源管理" class="headerlink" title="调度和资源管理"></a>调度和资源管理</h4><p>调度策略需要考虑：</p>
<ul>
<li>公平性</li>
<li>有差别的响应性</li>
<li>有效性<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/91b7d7017b28f3c83e467190be1604282b540498dad5134a93f41493cb8c4d13.png" alt="多道程序环境中涉及进程调度和资源分配的主要组件" title>
                </div>
                <div class="image-caption">多道程序环境中涉及进程调度和资源分配的主要组件</div>
            </figure>  

</li>
</ul>
<h3 id="现代操作系统的特征"><a href="#现代操作系统的特征" class="headerlink" title="现代操作系统的特征"></a>现代操作系统的特征</h3><ul>
<li>微内核：只给内核分配基本功能（地址空间、进程间通信 <code>IPC</code>、基本的调度）<ul>
<li>优点：简化实现、灵活、适合分布式</li>
</ul>
</li>
<li>多线程<ul>
<li>线程：可分派的工作单元。包括上下文、数据区域</li>
<li>进程：一个或多个线程和相关<strong>系统资源</strong>的集合</li>
</ul>
</li>
<li>对称多处理：多处理器架构，且每个处理器地位相同<ul>
<li>多个进程/线程可以并行</li>
<li>多处理器对用户透明</li>
<li>OS 负责调度、同步</li>
<li>优点：性能、可用性、渐增性、扩展性</li>
</ul>
</li>
<li>分布式</li>
<li>面向对象<ul>
<li>给小内核增加模块化扩展、定制操作系统</li>
</ul>
</li>
</ul>
<h3 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h3><p>操作系统相关技术：</p>
<ul>
<li>进程隔离</li>
<li>并发控制</li>
<li>虚拟机</li>
<li>检测点和回滚机制</li>
</ul>
<h3 id="多处理器和多核操作系统考虑因素"><a href="#多处理器和多核操作系统考虑因素" class="headerlink" title="多处理器和多核操作系统考虑因素"></a>多处理器和多核操作系统考虑因素</h3><p>关键问题：</p>
<ul>
<li>并发进程或线程</li>
<li>调度</li>
<li>同步</li>
<li>内存管理</li>
<li>可靠性、容错性</li>
</ul>
<p>多核系统潜在的并行能力有三个层次</p>
<ul>
<li>应用程序以多线程形式执行能力</li>
<li>多处理器的多线程程序执行能力</li>
<li>核内部硬件并行、指令集并行</li>
</ul>
<p>OS 常用策略：</p>
<ul>
<li>应用层并行</li>
<li>虚拟机</li>
</ul>
<h3 id="主流操作系统（略）"><a href="#主流操作系统（略）" class="headerlink" title="主流操作系统（略）"></a>主流操作系统（略）</h3><h4 id="单体内核"><a href="#单体内核" class="headerlink" title="单体内核"></a>单体内核</h4><ul>
<li>单体内核：在一大块代码中包含了所有的操作系统功能，作为单个进程运行，具有唯一的地址空间</li>
<li>所有的功能部件都可以访问内核数据结构和例程</li>
<li>Linux 虽然是单体内核，但是采用了模块化结构</li>
</ul>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>本章直接占 1/3 课时</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/fe85f271b767ca86e4b154493f7cb0f354da2892642000abfdb928429fbe321e.png" alt="主要内容" title>
                </div>
                <div class="image-caption">主要内容</div>
            </figure>

<h3 id="进程描述与控制"><a href="#进程描述与控制" class="headerlink" title="进程描述与控制"></a>进程描述与控制</h3><h4 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h4><p>进程：一段代码执行的时候就称为进程</p>
<p>进程 = 代码 + 相关数据</p>
<p>进程由以下元素表征：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/de668abd9bc9d7c3d0f07b76b768bfa8f91b1e3275d7385d8d2930fbd799f100.png" alt="进程的元素" title>
                </div>
                <div class="image-caption">进程的元素</div>
            </figure>

<ul>
<li>上下文数据（狭义，此处）：CPU寄存器<ul>
<li>广义：图中全部数据</li>
</ul>
</li>
<li>记账信息：统计信息（CPU 时长等）</li>
</ul>
<p>进程控制块 <code>Process Control Block</code>, <code>PCB</code></p>
<ul>
<li>各操作系统不同</li>
<li>用于中断进程后恢复进程</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/3740fece581f214cb7edc5431a02a5107d0a75677b24f5303471285d9e332d8f.png" alt="进程控制块" title>
                </div>
                <div class="image-caption">进程控制块</div>
            </figure>  

<p>进程特征：</p>
<ul>
<li>动态性（存在生命周期，本质特征）</li>
<li>并发性（重要特征）</li>
<li>独立性</li>
<li>异步性：按各自独立的、不可预知的速度向前推进<ul>
<li>为什么速度不可预知？——存在中断等</li>
</ul>
</li>
</ul>
<p>进程与程序比较：</p>
<ul>
<li>进程：正在运行的程序实例</li>
<li>进程 = 进程控制块 + 程序 + 相关数据</li>
<li>引入进程概念为并发</li>
<li>程序静态，进程动态</li>
<li>“程序 - 进程”不是一对一<ul>
<li>反例：程序对应用户进程和内核进程；一个程序对应多个进程</li>
</ul>
</li>
</ul>
<h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><h5 id="进程轨迹"><a href="#进程轨迹" class="headerlink" title="进程轨迹"></a>进程轨迹</h5><ul>
<li>进程执行的指令序列，用来描述单个进程的行为</li>
<li>处理器的行为可以用多个进程交替执行的轨迹来描述 </li>
</ul>
<p><img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/16f4abf3eaf38c3a612a2c504b544cdf5cdc8bb602001aeddada7e6b2fc89337.png" alt="示例"></p>
<h5 id="进程的的两状态模型"><a href="#进程的的两状态模型" class="headerlink" title="进程的的两状态模型"></a>进程的的两状态模型</h5><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/dd44338af4c33499f7c7ae41408036db934626e1c9bc9886360fba0d77504e8d.png" alt="进程的两状态模型" title>
                </div>
                <div class="image-caption">进程的两状态模型</div>
            </figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/1aa7a23cbaebde3a10eaed151a557601867cc782591daff2e4ebb939f7b8dcf8.png" alt="进程的两状态模型的排队图" title>
                </div>
                <div class="image-caption">进程的两状态模型的排队图</div>
            </figure>

<h5 id="进程的创建和终止"><a href="#进程的创建和终止" class="headerlink" title="进程的创建和终止"></a>进程的创建和终止</h5><p>进程创建的原因：</p>
<ul>
<li>新的批处理作业</li>
<li>（终端用户）交互登陆</li>
<li>为提供服务而由操作系统创建</li>
<li>由现有进程派生<ul>
<li>父进程、子进程</li>
</ul>
</li>
</ul>
<p>进程终止：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/5c072002825672f047f542af8992172a7ab3a2ffb4a5b11088d2eccca0dd871d.png" alt="终止的原因" title>
                </div>
                <div class="image-caption">终止的原因</div>
            </figure>  

<h5 id="进程的五状态模型"><a href="#进程的五状态模型" class="headerlink" title="进程的五状态模型"></a>进程的五状态模型</h5><p>将 Not Running 细分为就绪（等 CPU）和阻塞（等 I/O 之类的），得到了五状态模型：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/3d673eb64b22f2459f6c4e5d9b9ac13b8aca70e505a5817266e10c9f249c0b17.png" alt="进程的五状态模型" title>
                </div>
                <div class="image-caption">进程的五状态模型</div>
            </figure>  

<p>排队模型</p>
<ul>
<li>多阻塞队列</li>
<li>多就绪队列（优先级不同）</li>
<li>退出状态（保留记账信息等）</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/ec439cb6c9d1ee4150f9068254d3a41a567018577184e643ed883609c788c465.png" alt="进程的五状态模型的排队图" title>
                </div>
                <div class="image-caption">进程的五状态模型的排队图</div>
            </figure>  

<p><img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/40c97dc5b2edb605614fc76316da3e8eee5e78b0770e66b20288f763e0351b74.png" alt="进程的五状态模型的排队图（多阻塞队列）">  </p>
<h5 id="挂起"><a href="#挂起" class="headerlink" title="挂起"></a>挂起</h5><p>挂起的进程：</p>
<ul>
<li>原因：内存资源紧张、无就绪进程（进程全阻塞等待 I/O）</li>
<li>交换：把内存的一个进程的部分或全部移到磁盘中（挂起状态），然后从挂起队列取一个进程/接纳一个新进程</li>
<li>挂起状态：将内存中处于阻塞、就绪、甚至是执行状态的进程放到外存，不再参与 CPU 的竞争</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/5511e243d259901289032791547d2a731bc613a177ef95b94c5c7431fc9334f1.png" alt="挂起状态图" title>
                </div>
                <div class="image-caption">挂起状态图</div>
            </figure>

<p>为区分两种挂起，便有了<strong>七状态的挂起状态图</strong>（重点）：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/98346f16297884d5a770f909fdf8ec6ed0c7ec9f525ea2cc1b176e44e8a2260c.png" alt="七状态的挂起状态图" title>
                </div>
                <div class="image-caption">七状态的挂起状态图</div>
            </figure>

<p>挂机进程特征：</p>
<ul>
<li>不能立即执行</li>
<li>可能在等待事件</li>
<li>被一个代理（自身、父进程或 os）挂起</li>
<li>被代理（取出）</li>
</ul>
<p>进程挂起的原因：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/e1e64fb637b2b627e7c59ab74602297000a3d101436c7d3e2817d346c1790dfc.png" alt="进程挂起的原因" title>
                </div>
                <div class="image-caption">进程挂起的原因</div>
            </figure>

<h4 id="进程描述"><a href="#进程描述" class="headerlink" title="进程描述"></a>进程描述</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/d41f5a0daf9d2e9a104f41da70c9e9dd25d3d539fb2c6c7d87c707b1b5aaf1cb.png" alt="进程的三种情况" title>
                </div>
                <div class="image-caption">进程的三种情况</div>
            </figure>  

<p><img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/52eaa607258e69c198ab6c4e40033add64cd587f4b94c934327b5cc60d476728.png" alt="操作系统的控制结构"></p>
<p>内存表：用于跟踪内存和外存</p>
<ul>
<li>外存使用虚拟存储或交换机制</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/5e0d4e81502fd32090dc5bc0903b16c3a084a1459d2715a94a0f51ca4fe12ec1.png" alt="内存表组成" title>
                </div>
                <div class="image-caption">内存表组成</div>
            </figure>  

<p>I/O 表：</p>
<ul>
<li>I/O 的状态</li>
<li>源/目标的内存单元</li>
</ul>
<p>文件表：</p>
<ul>
<li>是否存在</li>
<li>在外存中的位置</li>
<li>当前状态</li>
<li>其他属性</li>
</ul>
<p>进程表</p>
<ul>
<li>用于管理进程</li>
<li>表中有内存、I/O、文件的引用</li>
<li>表能被 OS 访问</li>
<li>OS 需要知道：进程的位置、属性<ul>
<li>位置包含：程序、数据、（调用）栈</li>
<li>属性即 PCB</li>
<li>程序、数据、栈和属性构成<strong>进程映像</strong></li>
</ul>
</li>
</ul>
<p>PCB 中的信息：</p>
<ul>
<li>进程标识信息<ul>
<li>进程的唯一标识符 <code>ID</code>，构成索引</li>
<li>父进程 ID</li>
<li>用户 ID</li>
</ul>
</li>
<li>处理器状态信息<ul>
<li>由寄存器内容组成<ul>
<li>用户可见寄存器</li>
<li>控制、状态寄存器</li>
<li>栈指针</li>
</ul>
</li>
<li>被设计为程序状态字 <code>PSW</code> 寄存器</li>
</ul>
</li>
<li>进程控制信息<ul>
<li>调度和状态信息（进程状态、优先级、调度相关信息、等待事件的标识）</li>
<li>数据结构（用队列、环等链接到其他进程）</li>
<li>进程间通信（两个进程通信的相关信息）</li>
<li>进程特权</li>
<li>存储管理（进程虚存的段表、页表的指针）</li>
<li>进程所有权、使用情况（打开的文件、使用历史）</li>
</ul>
</li>
</ul>
<p>进程表 = n * 进程状态<br>进程映像 = 程序 + 数据 + 栈 + 属性 (PCB)<br>PCB = 进程标识信息（三个 ID） + 处理器状态信息 (PSW) + 进程控制信息</p>
<h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><h5 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h5><p>内核 <code>kernel</code>：操作系统的核心</p>
<ul>
<li>操作系统中的重要系统功能</li>
<li>常驻内存</li>
<li>功能：资源管理、支撑功能<ul>
<li>资源管理：进程管理、存储管理、I/O 设备管理（文件管理放在核外）</li>
<li>支撑功能：中断处理、时钟管理、记账功能</li>
</ul>
</li>
</ul>
<blockquote>
<p>中断处理既是内核的基本功能，也是整个操作系统赖以活动的基础，操作系统的一切重要活动最终都依赖于中断。</p>
</blockquote>
<h5 id="执行模式"><a href="#执行模式" class="headerlink" title="执行模式"></a>执行模式</h5><p>大多数处理器至少支持：</p>
<ul>
<li>用户模式<ul>
<li>优先权较少</li>
<li>运行用户程序</li>
</ul>
</li>
<li>系统模式/内核模式/控制模式<ul>
<li>优先权更高</li>
<li>运行内核</li>
<li>某些指令、内存只能在特权模式下运行/访问<ul>
<li>读取/修改 PSW 等控制寄存器</li>
<li>原始 I/O 指令</li>
<li>内存管理相关</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>原因：保护 OS 和重要操作系统表不受程序干扰</p>
<p>IA-64 处理器的 PSWR 中存在指示执行模式的位</p>
<ul>
<li>当用户调用操作系统服务或中断促发系统例程时，相关位被置为内核模式</li>
<li>当从系统服务返回用户进程时，执行模式置为用户模式</li>
</ul>
<blockquote>
<p>系统调用 <code>system call</code> 是 OS 为用户提供的接口。</p>
</blockquote>
<h5 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h5><p>回忆<a href="#进程的创建和终止">进程创建的原因</a>？</p>
<p>创建进程的流程：</p>
<ol>
<li>分配唯一标识符</li>
<li>分配空间</li>
<li>初始化 PCB（标识信息、处理器状态信息、控制信息）</li>
<li>建立链接，将其插入就绪或就绪/挂起链表</li>
<li>建立/扩充其他数据结构</li>
</ol>
<h5 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h5><p>下均指用户模式下的进程切换。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/1fa3ae807c84a1155891b41760a02678c0213adbe7747274b173c93c1ec79b88.png" alt="进程切换的时机" title>
                </div>
                <div class="image-caption">进程切换的时机</div>
            </figure>

<h6 id="系统中断"><a href="#系统中断" class="headerlink" title="系统中断"></a>系统中断</h6><p>系统中断：普通中断和陷阱</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/fb6259090137f1b462f3985e993b822b64b63cff0aec0a38e579d29f7a9fcd7c.png" alt="普通终端和陷阱" title>
                </div>
                <div class="image-caption">普通终端和陷阱</div>
            </figure>  

<ul>
<li>内存失效：缺页等</li>
<li>中断不一定导致进程切换（<code>getpid()</code> 系统调用引发中断，但没有进程切换）</li>
</ul>
<h6 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h6><p>模式切换：<a href="#执行模式">用户模式和内核模式</a>之间的相互转换。</p>
<p>原因：</p>
<ul>
<li><p>系统调用</p>
</li>
<li><p>中断</p>
<ul>
<li>中断出现时，</li>
<li>将程序计数器置为中断处理程序的开始地址</li>
<li>从用户模式切换到内核模式，以便中断处理能执行特权指令</li>
</ul>
</li>
<li><p>模式切换不一定导致进程切换（<code>getpid()</code> 系统调用引发中断，但没有进程切换）</p>
</li>
<li><p>进程切换一定会有模式切换（<code>进程切换</code>一定要在内核模式下进行）</p>
</li>
</ul>
<h6 id="进程状态转换"><a href="#进程状态转换" class="headerlink" title="进程状态转换"></a>进程状态转换</h6><ul>
<li>模式切换可在不改变运行进程状态下出现</li>
<li>进程切换会导致当前进程的状态转换（就绪、阻塞等）</li>
</ul>
<p>进程切换步骤：</p>
<ul>
<li>保存处理器上下文<ul>
<li>包括程序计数器和其它寄存器</li>
</ul>
</li>
<li>更新当前进程的 PCB<ul>
<li>状态、数据结构等变化</li>
</ul>
</li>
<li>将进程的进程控制块移至相应队列<ul>
<li>就绪、阻塞、就绪/挂起等</li>
</ul>
</li>
<li>选择另一进程执行</li>
</ul>
<p>（切换回来的步骤）：</p>
<ul>
<li>更新该进程的 PCB</li>
<li>更新内存管理数据结构</li>
<li>恢复被选择进程的上下文</li>
</ul>
<h5 id="操作系统的执行"><a href="#操作系统的执行" class="headerlink" title="操作系统的执行"></a>操作系统的执行</h5><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/ddde0c35862ae06c5a019a286f2d1c36dc01285685570da3d68f951a4f16ebbb.png" alt="操作系统的执行" title>
                </div>
                <div class="image-caption">操作系统的执行</div>
            </figure>  


<h4 id="Unix-SVR4-的进程管理"><a href="#Unix-SVR4-的进程管理" class="headerlink" title="Unix SVR4 的进程管理"></a>Unix SVR4 的进程管理</h4><h5 id="进程状态切换"><a href="#进程状态切换" class="headerlink" title="进程状态切换"></a>进程状态切换</h5><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/1c01e23a1752eae3007999b4d1bc99ca977e01dd0f8bfd055c667d57648eae3b.png" alt="进程状态切换" title>
                </div>
                <div class="image-caption">进程状态切换</div>
            </figure>  

<ul>
<li>阻塞在 Unix SVR4 中被称为 <code>Sleep</code>。</li>
</ul>
<h5 id="Unix-SVR4-的进程创建"><a href="#Unix-SVR4-的进程创建" class="headerlink" title="Unix SVR4 的进程创建"></a>Unix SVR4 的进程创建</h5><ul>
<li>内核系统调用 <code>fork()</code>，在内核模式下完成</li>
</ul>
<ol>
<li>在<strong>进程表</strong>中为新进程分配一个空项</li>
<li>为子进程分配一个唯一的<strong>进程标识符</strong></li>
<li>复制父进程的<strong>进程映象</strong>，但共享内存除外</li>
<li>增加父进程所拥有的文件的计数器，反映另一个进程现在也拥有这些文件的事实</li>
<li>将子进程设置为就绪态</li>
<li>将子进程的 ID 号返回给父进程，将 0 值返回给子进程</li>
</ol>
<ul>
<li><code>fork()</code> 的返回值：-1（出错）、0（无子进程）、正值（子进程的 ID）</li>
<li>进程创建后，可能发生：<ul>
<li>控制权：父进程，执行点：调用 fork 的位置</li>
<li>控制权：子进程，执行点：调用 fork 的位置</li>
<li>控制权：其他进程（当前父子进程处于就绪态）</li>
</ul>
</li>
<li>最终父进程和子进程均会在下一条语句上继续运行</li>
</ul>
<p>例题 1：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello"</span>);</span><br><span class="line">  fork(); </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Bye"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出 <code>HelloByeBye</code>，但父子进程输出 <code>Bye</code> 的顺序未知。</p>
<p>例题 2：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    fork();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello, world\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出 8 个 <code>hello, world</code>。</p>
<p>例题 3：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buffer[<span class="number">10</span>];</span><br><span class="line">  <span class="keyword">if</span> (fork()==<span class="number">0</span>)     </span><br><span class="line">    <span class="built_in">strcpy</span>(buffer, <span class="string">"Child\n"</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">strcpy</span>(buffer, <span class="string">"Parent\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    write(<span class="number">1</span>, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序的运行无法保证输出顺序，输出顺序依赖于内核所用的调度算法。<br>在 <code>Ubuntu 20.04 LTS</code> 测试结果如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test.c -o <span class="built_in">test</span></span><br><span class="line">$ ./<span class="built_in">test</span></span><br><span class="line">Parent</span><br><span class="line">Child</span><br><span class="line">Parent</span><br><span class="line">Child</span><br><span class="line">Parent</span><br><span class="line">Child</span><br><span class="line">Parent</span><br><span class="line">Child</span><br><span class="line">Parent</span><br><span class="line">Child</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>例题 4：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global = <span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pid; </span><br><span class="line">  <span class="keyword">int</span> vari = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"before fork\n"</span>);</span><br><span class="line">  <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    global++;</span><br><span class="line">    vari--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"global=%d,vari=%d\n"</span>, global, vari);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后，变量值如下表：</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>父进程</th>
<th>子进程</th>
</tr>
</thead>
<tbody><tr>
<td><code>global</code></td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td><code>vari</code></td>
<td>5</td>
<td>4</td>
</tr>
</tbody></table>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><h5 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h5><p>进程的两个属性（拥有资源、调度/执行的基本单位）是独立的，OS 应该能独立处理它们，为此引入线程。</p>
<ul>
<li>调度并分派的单位通常称为线程或轻量级进程(LWP)</li>
<li>资源所有权的单位通常称为进程</li>
</ul>
<p>多线程(multithreading)：操作系统在单个进程内支持多个并发路径的能力。</p>
<p>单线程：每个进程中只有一个线程在执行（没有考虑线程的概念）。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/c9c7e964cbd4db9b84ec977c862c66c5ac919780cf218c9f1dcb625d3674e302.png" alt="多进程与多线程" title>
                </div>
                <div class="image-caption">多进程与多线程</div>
            </figure>  

<p>多线程环境中，与进程相关的资源和保护：</p>
<ul>
<li>容纳进程映像的虚地址空间（回忆进程映像？）</li>
<li>受保护的访问：<ul>
<li>处理器</li>
<li>其他进程（进程间通信时，以进程为单位）</li>
<li>文件</li>
<li>I/O 资源</li>
</ul>
</li>
</ul>
<p>一个进程中可能有多个线程，每个线程有：</p>
<ul>
<li>执行状态（运行、就绪等）</li>
<li>未运行时保存的线程上下文（寄存器值）</li>
<li>执行栈（过程调用）</li>
<li>用于局部变量的静态存储空间</li>
<li>与进程内其他线程共享的内存和资源访问</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/d413ee8142e7bec16c3bc644d1c611d8c5447b212039cba415eb8fae3a04ec76.png" alt="单进程和多进程模型" title>
                </div>
                <div class="image-caption">单进程和多进程模型</div>
            </figure>

<p>进程控制块 <code>Thread Control Block</code> 较 PCB 会简单很多。</p>
<p>进程的优点：</p>
<ul>
<li>创建线程的时间少于创建进程时间（TCB 简单）</li>
<li>终止线程比终止进程所花时间少</li>
<li>同一进程内线程切换时间，少于进程切换时间（上下文、数据结构少）</li>
<li>线程提高了不同执行程序间通信的效率（线程间通信）</li>
</ul>
<p>调度和分派：在线程基础上</p>
<ul>
<li>大多数与线程相关的信息保存在线程级的数据结构中</li>
<li>挂起一个进程 == 挂起内部所有线程</li>
<li>终止一个进程 == 终止内部所有线程</li>
</ul>
<p>线程主要状态：</p>
<ul>
<li>运行</li>
<li>就绪</li>
<li>阻塞<br>和线程状态变化相关的基本操作：</li>
<li>派生</li>
<li>阻塞</li>
<li>解除阻塞</li>
<li>结束</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/74b533c2ae6d3895a26d1cf9568acfba32b8110db32111fd6bf09e3de5638fb1.png" alt="使用线程的远程过程调用示例" title>
                </div>
                <div class="image-caption">使用线程的远程过程调用示例</div>
            </figure>  

<p>如上，多线程能提高效率。</p>
<p>线程同步：</p>
<ul>
<li>一个进程中的所有线程共享一个地址空间和进程所拥有的资源</li>
<li>一个线程对共享资源的修改都将影响同一进程的其他线程的环境</li>
<li>具体方法在 [线程管理-同步]</li>
</ul>
<h5 id="线程分类"><a href="#线程分类" class="headerlink" title="线程分类"></a>线程分类</h5><ul>
<li>用户级线程 <code>User-Level Thread</code>, <code>ULT</code> </li>
<li>内核级线程 <code>Kernel-Level Thread</code>, <code>KLT</code></li>
</ul>
<p>Windows 采用的是内核级线程。</p>
<h6 id="用户级线程-ULT"><a href="#用户级线程-ULT" class="headerlink" title="用户级线程 ULT"></a>用户级线程 ULT</h6><p><strong>用户级线程对内核不可见</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/e8435fcc2d8c1c1ac0a9e29271b39ac9ac5a8a60779d8b90be3eba30d341919a.png" alt="用户级线程" title>
                </div>
                <div class="image-caption">用户级线程</div>
            </figure>  

<p><img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/9c693880d13dd43e005a7e588af26c7291462a7e13d07c7d40dfb45f4ff34bae.png" alt="（用户级）线程状态和进程状态"></p>
<p>用户级线程优点：</p>
<ul>
<li>线程切换不需要内核模式特权</li>
<li>调度策略因应用程序不同而不同</li>
<li>可以运行在任何操作系统上<br>缺点：</li>
<li>许多系统调用都会引起进程阻塞。当用户级线程执行系统调用时，不仅阻塞当前线程，还将引起同一进程中的其他线程阻塞</li>
<li>采用 ULT 策略，不能利用多处理器技术（OS 按进程分配处理器）<br>解决方法：</li>
<li>Jacketing（外套）技术：将一个可能产生阻塞的系统调用转换成一个非阻塞的系统调用</li>
<li>将应用程序写成多进程程序而不是多线程</li>
</ul>
<h6 id="内核级线程-KLT"><a href="#内核级线程-KLT" class="headerlink" title="内核级线程 KLT"></a>内核级线程 KLT</h6><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/b5d24596d24b0f853ea10751e0c16634169b6884e1ef48bdbf6ed2be7f4f7a39.png" alt="内核级线程" title>
                </div>
                <div class="image-caption">内核级线程</div>
            </figure>

<p>优点：</p>
<ul>
<li>内核可以把同一个进程内的多个线程调度到多处理器上</li>
<li>当一个线程阻塞时，内核可以调度同一进程内的其他线程</li>
<li>内核例程本身也可以是多线程的<br>缺点：</li>
<li>把控制权从一个线程传递到相同进程内的另一个线程时，需要切换到内核模式</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/e73c93ff19097507f860f0d0fd90db649ff848cd093afb4062390f4a904848d4.png" alt="线程和进程操作执行时间（µs）" title>
                </div>
                <div class="image-caption">线程和进程操作执行时间（µs）</div>
            </figure>  

<ul>
<li><code>Null Fork</code>: Fork 以后什么都不做</li>
<li><code>Signal Wait</code>: 一个进程/线程发出信号到另一个进程/线程收到信号</li>
<li>KLT 涉及到模式切换；进程涉及到共享空间等</li>
</ul>
<h6 id="混合方法"><a href="#混合方法" class="headerlink" title="混合方法"></a>混合方法</h6><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/319d2b33cddf7eecb0e9797f6a5e7a1300273389770ed8104706b5ab850e05dd.png" alt="混合方法" title>
                </div>
                <div class="image-caption">混合方法</div>
            </figure>  

<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><ul>
<li>如果有多个进程（线程）竞争 CPU，需要选择下一个要运行的进程（线程）</li>
<li>OS 中完成这部分工作的程序称为调度程序<code>scheduler</code></li>
<li>调度程序使用的算法称为调度算法<code>scheduling algorithm</code></li>
<li>调度的目的：满足系统目标（响应时间、吞吐量、处理器效率）的方式，把进程分配到一个或多个处理器上执行</li>
</ul>
<h4 id="调度的类型"><a href="#调度的类型" class="headerlink" title="调度的类型"></a>调度的类型</h4><ul>
<li>长程调度</li>
<li>中程调度</li>
<li>短程调度</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/276c846bfdc127bacb591e1224689d2460e8ce934c50f0d9e09800ab155c7077.png" alt="调度与状态图" title>
                </div>
                <div class="image-caption">调度与状态图</div>
            </figure>  

<p><img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/8f3b60207781b74a7c41de935bb83508d4c6d9cbfae71c88208076fac3794440.png" alt="调度的层次">  </p>
<p><img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/544ae847b7d710680678853338fc26643b01aaae6aa24adcad89ee9c4acdb7a1.png" alt="具有三种调度的调度队列模型">  </p>
<h5 id="长程调度"><a href="#长程调度" class="headerlink" title="长程调度"></a>长程调度</h5><ul>
<li>决定哪个程序可以进入系统中处理</li>
<li>控制系统中并发的度<ul>
<li>创建的进程越多，每个进程执行的时间比例越小</li>
<li>可能限制并发的度给当前进程集提供满意的服务</li>
</ul>
</li>
</ul>
<p>从作业队列中选择作业来创建进程， 为此，需考虑：</p>
<ol>
<li>何时操作系统能够接纳一个和多个进程</li>
<li>接纳哪个作业为之创建进程（先来先服务，或根据    优先级、期望的执行时间、I/O需求）</li>
</ol>
<h5 id="中程调度"><a href="#中程调度" class="headerlink" title="中程调度"></a>中程调度</h5><ul>
<li>中程调度是交换功能的一部分</li>
<li>换入决定取决于系统并发度的需求</li>
<li>在不使用虚存的系统中，换入决策还需考虑换出进程的存储需求</li>
</ul>
<h5 id="短程调度"><a href="#短程调度" class="headerlink" title="短程调度"></a>短程调度</h5><ul>
<li>短程调度称为分派程序</li>
<li>执行最频繁</li>
<li>精确决定下次执行哪个进程</li>
<li>导致当前进程阻塞或抢占当前运行进程的事件发生时，调用短程调度程序<ul>
<li>事件：时钟中断、I/O 中断、系统调用、信号</li>
</ul>
</li>
</ul>
<h4 id="调度的规则"><a href="#调度的规则" class="headerlink" title="调度的规则"></a>调度的规则</h4><h5 id="调度相关基本概念"><a href="#调度相关基本概念" class="headerlink" title="调度相关基本概念"></a>调度相关基本概念</h5><ul>
<li>响应时间：从<strong>用户提交</strong>一个请求开始，到接收响应之间的时间间隔<ul>
<li><strong>响应时间 = 输入传送时间 + 处理时间 + 响应传送时间</strong></li>
</ul>
</li>
<li>截止时间：某任务必须开始执行/必须完成的最迟时间</li>
<li>吞吐量：在单位时间内，系统完成的进程数</li>
<li>处理器利用率：处理器处于忙状态的时间百分比</li>
<li>周转时间：<strong>进程</strong>从提交到完成的时间<ul>
<li><strong>周转时间 = 等待资源的时间 + 执行时间</strong><ul>
<li>等待资源的时间 = 就绪 + 阻塞 + 就绪/挂起 + 阻塞/挂起</li>
<li>注意“周转时间”和“响应时间”针对的主体不同</li>
</ul>
</li>
</ul>
</li>
<li>平均周转时间：多个进程周转时间的平均值</li>
<li>平均带权周转时间：多个进程带权周转时间（周转时间与系统为它提供的服务时间之比）的平均值<ul>
<li>$带权周转时间 = T/S \geq 1$。若 $T/S=1$ 说明进程来了立即被调用，无需等待</li>
</ul>
</li>
</ul>
<p>短程调度的主要目标：按照优化系统某些方面的方式，来分配处理器时间</p>
<h5 id="调度规则总结"><a href="#调度规则总结" class="headerlink" title="调度规则总结"></a>调度规则总结</h5><ul>
<li>面向用户，与性能相关：周转时间、响应时间、 最后期限（截止时间）</li>
<li>面向用户，与性能无关：可预测性</li>
<li>面向系统，与性能相关：吞吐量、 处理器利用率</li>
<li>面向系统，与性能无关：公平性、强制优先级、平衡资源</li>
</ul>
<h5 id="优先级的使用"><a href="#优先级的使用" class="headerlink" title="优先级的使用"></a>优先级的使用</h5><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/dbba9e70c56d6c0fc1bb029b5b7434d118ff6171db5cd6a7b0e2032acfb6a6e2.png" alt="优先级的使用" title>
                </div>
                <div class="image-caption">优先级的使用</div>
            </figure>  

<ul>
<li>考虑进程优先级可能导致饥饿（低优先级进程迟迟无法运行），可以采用动态优先级方案（如根据等待时间变化优先级，等待时间过长后提高优先级）</li>
</ul>
<h4 id="调度的决策模式"><a href="#调度的决策模式" class="headerlink" title="调度的决策模式"></a>调度的决策模式</h4><p>调度的决策模式：</p>
<ul>
<li>非抢占（非剥夺）<ul>
<li>执行进程只有在执行完毕，或因申请 I/O 或请求某些操作系统服务而阻塞自己时，才释放处理器</li>
<li>OS 不会主动中断进程</li>
</ul>
</li>
<li>抢占（剥夺）<ul>
<li>执行进程可能被操作系统中断，并转换为就绪态</li>
<li>抢占可能发生在<ul>
<li>新进程到达时</li>
<li>中断发生后把一个阻塞进程置为就绪态</li>
<li>周期性的时钟中断</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>调度的选择函数：</p>
<ul>
<li>决定下次选择哪个就绪进程执行</li>
<li>可基于优先级、资源需求、进程的执行特性</li>
<li>基于执行特性时的基本参数：<ul>
<li><strong>w</strong> = 在系统里的等待时间</li>
<li><strong>e</strong> = 花费的执行时间</li>
<li><strong>s</strong> = 进程所需的总服务时间（含 <code>e</code>），需要估计或用户提供</li>
</ul>
</li>
</ul>
<h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><ul>
<li>系统的资源分配策 -&gt; 资源分配算法</li>
<li>对于不同的系统目标，采用不同的调度算法</li>
</ul>
<p>常见调度算法：</p>
<ul>
<li>先来先服务 <code>First Come First Served, FCFS</code></li>
<li>时间片轮转 <code>Round Robin, RR</code></li>
<li>短进程优先 <code>Shortest Process Next, SPN</code></li>
<li>剩余时间最短优先 <code>Shortest Remaining Time, SRT</code></li>
<li>响应比高者优先 <code>Highest Response Ratio Next, HRRN</code></li>
<li>反馈 <code>Feedback</code></li>
<li>……</li>
</ul>
<h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/a4f9bec23de25af74ea9a242ede66e56daad3565dad29e43007372b52492c347.png" alt="概述" title>
                </div>
                <div class="image-caption">概述</div>
            </figure>

<h5 id="先来先服务-FCFS"><a href="#先来先服务-FCFS" class="headerlink" title="先来先服务 FCFS"></a>先来先服务 FCFS</h5><ul>
<li>算法：First-Come-First-Served, <code>FCFS</code></li>
<li>也称为 FIFO</li>
<li>选择就绪队列中存在时间最长的进程运行</li>
<li>即按请求 CPU 的顺序使用 CPU</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/e2794f1eebb0563cc3b7451381a053d9f123ad6550fd31e67a268fb38a02d4c2.png" alt="示例" title>
                </div>
                <div class="image-caption">示例</div>
            </figure>

<p>算法评价：</p>
<ul>
<li>非抢占调度</li>
<li>有利于 CPU 繁忙型的进程（非抢占，能一直利用 CPU），而不利于 I/O 繁忙型的进程（需要反复排队 太惨了）</li>
<li>不适合直接用于单处理器系统,通常与其它调度算法混合使用</li>
<li>平均周转时间长</li>
<li>对长进程有利，不利于短进程</li>
</ul>
<h5 id="时间片轮转-RR"><a href="#时间片轮转-RR" class="headerlink" title="时间片轮转 RR"></a>时间片轮转 RR</h5><ul>
<li>算法：Round Robin, <code>RR</code></li>
<li>每个进程被分配一个时间片，周期性产生时钟中断，中断时当前进程进入就绪队列末尾，基于 FCFS 选择下一个作业运行</li>
<li>如果进程在时间片内阻塞或结束，则立即切换 CPU</li>
<li>RR 算法在通用的分时系统或事务处理系统中特别有效</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/e2d616552ffc0ae85c84d1b6241dd3ff23b4a74b85519b55f44e484e570851e3.png" alt="示例" title>
                </div>
                <div class="image-caption">示例</div>
            </figure>  

<p>图中 <code>q</code> 为时间片长度，下同。</p>
<p><strong>注意，D 到达的同时 C 调度时间片结束，此时优先级： D &gt; C。</strong></p>
<p>算法评价：</p>
<ul>
<li>属于抢占调度方式</li>
<li>常用于分时系统或事务处理系统</li>
<li>时间片的设置与系统性能、响应时间密切相关<ul>
<li>时间片太短——进程切换频繁，降低 CPU 效率</li>
<li>时间片太长——引起对短的交互请求的响应时间变长。</li>
<li>时间片最好略大于一次典型交互的时间</li>
</ul>
</li>
<li>对 CPU 密集型进程有利，对 I/O 型密集型进程不利（用不完一个时间片）</li>
<li><strong>改进：Virtural RR 算法</strong><ul>
<li>增加一个辅助队列，接收 I/O 阻塞完成的进程</li>
<li>调度优先于就绪队列</li>
<li>但占用的处理器时间小于就绪队列</li>
<li>类似于超市的快速结账通道</li>
<li>VRR 算法比 RR 算法公平</li>
</ul>
</li>
</ul>
<h5 id="短进程优先-SPN"><a href="#短进程优先-SPN" class="headerlink" title="短进程优先 SPN"></a>短进程优先 SPN</h5><p>算法: Shortest Job(Process) First(Next), <code>SJF</code>/<code>SPF</code>/<code>SPN</code></p>
<ul>
<li>短进程或短作业优先调度</li>
<li>前提为执行时间预知</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/0ea56c428a5734629be630d7c9e98151782ee77d30c55d099ef5bd32fe20e70c.png" alt="示例" title>
                </div>
                <div class="image-caption">示例</div>
            </figure>  

<p>算法评价：</p>
<ul>
<li>非抢占</li>
<li>长进程饥饿</li>
<li>有利于短进程，减小了平均周转时间</li>
<li>缺少剥夺机制，不适用于分时系统/事务处理环境</li>
<li>用户估计不准时，算法不一定能真正做到短作业优先调度</li>
</ul>
<h5 id="剩余时间最短优先-SRT"><a href="#剩余时间最短优先-SRT" class="headerlink" title="剩余时间最短优先 SRT"></a>剩余时间最短优先 SRT</h5><p>算法: Shortest Remaining Time, <code>SRT</code></p>
<ul>
<li>调度程序总是选择预期剩余时间最短的进程</li>
<li>当一个新进程加入就绪队列时，如果它比当前运行的进程具有更短的剩余时间，就可能抢占当前正在运行的进程</li>
<li><strong>在 SPN 的基础上增加了剥夺机制</strong></li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/b830f9af056042c3b3fb157d6fac999b5d8dcc1c59e4bf792dc8c92046ea1a31.png" alt="示例" title>
                </div>
                <div class="image-caption">示例</div>
            </figure>  

<p>算法评价：</p>
<ul>
<li>优点<ul>
<li>既不像 FCFS 那样偏爱长进程，也不像 RR 算法那样会产生很多额外的中断（因时间片而产生），从而减少了开销</li>
<li>周转时间方面，SRT 比 SJF 性能要好，只要就绪，短作业可以立即被选择执行</li>
</ul>
</li>
<li>问题<ul>
<li>需要估计预期的服务时间</li>
<li>存在长进程饥饿现象</li>
<li>必须记录进程的已服务时间</li>
</ul>
</li>
</ul>
<h5 id="响应比高者优先-SRRN"><a href="#响应比高者优先-SRRN" class="headerlink" title="响应比高者优先 SRRN"></a>响应比高者优先 SRRN</h5><p>算法: Highest Response Ratio Next, HRRN</p>
<ul>
<li>当前进程执行完毕或需要阻塞时，选择就绪队列中响应比 $R_p$ 最高的进程投入执行<br>$$R_p = \frac{等待时间+要求服务时间}{要求服务时间} = \frac{w+s}{s}$$</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/44fc51e62cc23ed7e5a337fbca7e62f66bc770aa0a4d4b1a5f9e63462020c674.png" alt="示例" title>
                </div>
                <div class="image-caption">示例</div>
            </figure>  

<p>算法评价：</p>
<ul>
<li>非抢占</li>
<li>一种动态优先权调度算法</li>
<li>算法说明了进程的年龄</li>
<li>是 FCFS 和 SJF 的结合，既照顾了短进程，又考虑了作业到达的先后次序，不会使长进程长期得不到服务</li>
<li>但每次调度之前，都须先做响应比的计算，会增加系统开销，且难以准确计算</li>
</ul>
<h5 id="反馈调度法-Feedback"><a href="#反馈调度法-Feedback" class="headerlink" title="反馈调度法 Feedback"></a>反馈调度法 Feedback</h5><p>SPN、SRT、SRRN 采用了“奖励短进程”的思想。虽然性能较好，但均基于进程的<strong>预期</strong>执行时间。</p>
<p>算法思想：</p>
<ul>
<li>采用<strong>惩罚运行时间较久的进程</strong>的思想</li>
<li>关注的是<strong>已经执行</strong>的时间</li>
<li>根据进程执行历史，调度基于抢占原则（按时间片）</li>
<li>动态优先级</li>
<li>采用多级队列区别对待的方法——惩罚长进程</li>
<li><strong>多个独立的、优先级不同的就绪队列</strong>，优先调度优先级高的队列</li>
<li>进程执行过程中可降级</li>
<li>算法有多个变种（主要区别在于抢占机制不同）</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/0157b7d6af35892595f8dc7b2ad08c71e0204d59b2df82cc7a6ae3051c392c3a.png" alt="调度队列" title>
                </div>
                <div class="image-caption">调度队列</div>
            </figure>  

<p>（基于时间片轮转的）反馈调度算法：Feedback, <code>FB</code></p>
<ol>
<li>设置多个就绪队列，每个队列赋予不同优先级<ul>
<li>第一队列优先级最高，依次递减</li>
<li>各个队列中进程执行的时间片不同</li>
<li>优先级越高的队列，时间片越小</li>
</ul>
</li>
<li>新进程进入时，首先放入第一个队列尾，按 FCFS 原则排队</li>
<li>如果进程在当前队列的时间片内完成则退出</li>
<li>一般而言，从队列 $i$ 中调度的进程<strong>允许执行 $q=2^i$ 的时间，然后才被抢占</strong>，降级到下一个优先级队列<ul>
<li>如果时间片到达而没有被抢占（无其他进程需调度），则当前进程继续运行且暂时不降级。此后，一旦新进程出现，原进程会被立即抢占（无视时间片）并降级</li>
<li>队列标号从 0 开始</li>
</ul>
</li>
<li>到达最低优先级队列后，不再降级</li>
<li>仅当第一队列空闲时，才调度第二队列中的进程，依次类推</li>
</ol>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/d45dc487f6f1f948e555b7b454ffc4935c17eadfc3f7923b04a547f4a4c74e13.png" alt="示例" title>
                </div>
                <div class="image-caption">示例</div>
            </figure>  

<p>重点掌握！！！</p>
<p>注意，第 6 时刻 D 到达，此时 B 在第 2 队列，但没有被立即抢占。必须等 B 的时间片用完后才会进行抢占。</p>
<p>评价：多级反馈队列调度算法具有较好的性能，能较好地满足各种类型用户的需要</p>
<ul>
<li>终端型作业：有利（常为短作业，能在第一队列所规定的时间片内完）</li>
<li>短作业：有利（能在前几个队列所规定的时间片内完成）</li>
<li>长进程：将依次在第 1, 2, …, n 个队列中运行，随着优先级下降，分配的时间片长度增加，减少了抢占次数</li>
<li>问题：当不断有新进程到来时，长进程仍可能饥饿</li>
</ul>
<h4 id="实时系统与实时调度"><a href="#实时系统与实时调度" class="headerlink" title="实时系统与实时调度"></a>实时系统与实时调度</h4><ul>
<li>实时系统：系统能够及时（即时）响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行</li>
<li>对于实时系统而言，系统的正确性不仅取决于计算的结果，而且还依赖于产生结果的时间</li>
</ul>
<p><strong>实时系统 = 实时控制系统 + 实时信息处理系统</strong></p>
<ul>
<li>实时任务：具有及时性要求的、常常被重复执行的特定进。在实时系统中习惯称为任务</li>
<li>截止时间<ul>
<li>开始截止时间：任务在某时间以前<strong>必须</strong>开始执行</li>
<li>完成截止时间： 任务在某时间以前<strong>必须</strong>完成</li>
</ul>
</li>
</ul>
<h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ul>
<li>按截止时间分：<ul>
<li>硬实时任务（必须在截止时间前开始/完成）</li>
<li>软实时任务（可以稍微延迟一些）</li>
</ul>
</li>
<li>按周期性分：<ul>
<li>周期性实时任务（每五秒就绪一次）</li>
<li>非周期性实时任务</li>
</ul>
</li>
</ul>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>可确定性(determinism)：任务按照固定的、预先确定的时间或时间间隔进行</li>
<li>可响应性(responsiveness)：关注系统在知道中断后为中断提供服务的的时间</li>
<li>用户控制(user control)：用户能够区分软、硬实时任务，并控制任务优先级</li>
<li>可靠性(reliability)：实时响应和控制事件，保障性能</li>
<li>失效弱化(fail-soft operation)：系统具有稳定性，当不能满足所有任务的实时性时，首先满足重要的、优先级高的任务的期限，减少系统故障</li>
</ul>
<h5 id="实时调度的两个维度"><a href="#实时调度的两个维度" class="headerlink" title="实时调度的两个维度"></a>实时调度的两个维度</h5><ul>
<li>调度方法：下次允许调度哪个任务</li>
<li>抢占方式：调度时采用什么抢占方式（抢占的时机如何）</li>
</ul>
<h5 id="调度方法"><a href="#调度方法" class="headerlink" title="调度方法"></a>调度方法</h5><h6 id="静态表驱动调度表"><a href="#静态表驱动调度表" class="headerlink" title="静态表驱动调度表"></a>静态表驱动调度表</h6><ul>
<li>用于调度<strong>周期性实时任务</strong></li>
<li>按照任务周期到达的时间、执行时间、完成截止时间 (ending deadline) 以及任务的优先级，制订调度表，调度实时任务</li>
<li><a href="#有完成限期的周期性实时任务">最早截止时间优先 <code>EDF</code></a> 调度算法即属于此类</li>
<li>此类算法不灵活，任何任务的调度申请改动都会引起调度表的修改</li>
</ul>
<h6 id="静态优先级抢占调度法"><a href="#静态优先级抢占调度法" class="headerlink" title="静态优先级抢占调度法"></a>静态优先级抢占调度法</h6><ul>
<li>此类算法多用于<strong>非实时多道程序系统</strong></li>
<li>优先级的确定方法很多，例如在分时系统中，可以对 I/O 密集型和 CPU 密集型的进程赋予不同的优先级</li>
<li>实时系统中一般根据任务的时间约束赋予优先级，例如<a href="#速率单调调度算法">速率单调调度算法 <code>RMS</code></a> 即是根据任务周期长度为实时任务赋予静态优先级。 </li>
</ul>
<h6 id="基于动态规划的调度法"><a href="#基于动态规划的调度法" class="headerlink" title="基于动态规划的调度法"></a>基于动态规划的调度法</h6><ul>
<li>当实时任务到达以后，系统为新到达的任务和正在执行的任务动态创建一张调度表</li>
<li>在当前执行进程不会错过其截止时间的条件下，如果也能使新到达任务在截止时间内完成，则立即调度执行新任务</li>
</ul>
<h6 id="动态尽力调度法"><a href="#动态尽力调度法" class="headerlink" title="动态尽力调度法"></a>动态尽力调度法</h6><ul>
<li>实现简单，广泛用于<strong>非周期性实时任务调度</strong></li>
<li>当任务到达时，系统根据其属性赋予优先级，优先级高的先调度。例如<a href="#有完成限期的周期性实时任务">最早截止时间优先 <code>EDF</code></a> 调度算法就采用了这种方法。这种算法总是尽最大努力尽早调度紧迫任务，因此称为“最大努力调度算法”</li>
<li>缺点在于，当任务完成，或截止时间到达时，<strong>很难知道该任务是否满足其约束时间</strong></li>
</ul>
<h5 id="抢占方式"><a href="#抢占方式" class="headerlink" title="抢占方式"></a>抢占方式</h5><h6 id="基于时间片的轮转调度"><a href="#基于时间片的轮转调度" class="headerlink" title="基于时间片的轮转调度"></a>基于时间片的轮转调度</h6><ul>
<li><strong>抢占</strong>方式</li>
<li>实时进程按时间片轮转的方式执行，到达的实时进程放在就绪队列尾</li>
<li>新到进程的时间片到时进行调度</li>
<li>响应时间一般为秒级</li>
<li>广泛用于分时系统及一般实时处理系统</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/1a7ff7c009c0d8165fac407523fe185914a9afed82c08179c321bd174d940d59.png" alt="示例" title>
                </div>
                <div class="image-caption">示例</div>
            </figure>

<h6 id="基于优先级的非抢占调度"><a href="#基于优先级的非抢占调度" class="headerlink" title="基于优先级的非抢占调度"></a>基于优先级的非抢占调度</h6><ul>
<li>实时进程按优先级、<strong>非抢占</strong>方式执行，新到的实时进程放在就绪队列首部</li>
<li>当前进程阻塞或完成时，立即调度新到进程</li>
<li>响应时间一般在数百毫秒至数秒范围</li>
<li>多用于多道批处理系统及<strong>不太严格的实时系统</strong></li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/f68c7064c7f8b900b53ae7be62e4650acc2fbb7d7dd7bc8624cc3b41af266cc4.png" alt="示例" title>
                </div>
                <div class="image-caption">示例</div>
            </figure>  

<h6 id="基于优先级的抢占点抢占调度"><a href="#基于优先级的抢占点抢占调度" class="headerlink" title="基于优先级的抢占点抢占调度"></a>基于优先级的抢占点抢占调度</h6><ul>
<li>实时进程按优先级、抢占方式执行</li>
<li>当下一个剥夺点(时钟中断)到来时，立即占用 CPU</li>
<li>响应时间一般在几毫秒至几十毫秒</li>
<li>用于<strong>一般实时系统</strong></li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/2cd1fdcbdb7a4876225188fd354391649b3be6ef25ca8ebbf31f15a9b2dbd45e.png" alt="示例" title>
                </div>
                <div class="image-caption">示例</div>
            </figure>  

<h6 id="立即抢占式调度"><a href="#立即抢占式调度" class="headerlink" title="立即抢占式调度"></a>立即抢占式调度</h6><ul>
<li>实时进程按优先级、抢占方式执行</li>
<li>响应时间为微秒至毫秒级</li>
<li>可用于苛刻的实时系统</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/189d229f6bff53861ede276608416ef5325b9ae153a04bcc564f69f8e16cafbb.png" alt="示例" title>
                </div>
                <div class="image-caption">示例</div>
            </figure>  

<h5 id="实时调度示例"><a href="#实时调度示例" class="headerlink" title="实时调度示例"></a>实时调度示例</h5><p>实时调度基于实时任务的信息：</p>
<ul>
<li>就绪时间</li>
<li>启动的限期 <code>starting deadline</code></li>
<li>完成的限期 <code>completion deadline</code></li>
<li>处理的时间：任务执行到完成的时间</li>
<li>资源需求：任务执行过程中所需的资源集</li>
<li>优先级：度量任务的相对重要性</li>
<li>子任务结构：一个任务可分解为一个必须执行的子任务和一个可选执行子任务，前者有硬截止时间 <code>hard deadline</code></li>
</ul>
<p>实时调度需要考虑的两个问题：</p>
<ul>
<li>下次调度哪个任务？——选择 deadline 最早的任务</li>
<li>使用什么抢占方式？<ul>
<li>对于<strong>启动限期</strong>明确的任务，采用<strong>非抢占</strong>方式</li>
<li>对于具有<strong>完成限期</strong>的实时系统，采用<strong>抢占</strong>策略</li>
</ul>
</li>
</ul>
<h6 id="有完成限期的周期性实时任务"><a href="#有完成限期的周期性实时任务" class="headerlink" title="有完成限期的周期性实时任务"></a>有完成限期的周期性实时任务</h6><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/9c1838f926b4f5176fcb7cac19ac6fabd5fcff7aa5099df3d27d7b7310ab0a74.png" alt="两个周期性任务的执行信息" title>
                </div>
                <div class="image-caption">两个周期性任务的执行信息</div>
            </figure>  

<p><img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/40c1ab3af7398095bbc630ae8b35544533fb763af64e62b3ca1ee46430b257ca.png" alt="不同执行策略和效果">  </p>
<p>可见，<strong>按“最早完成截止时间优先” <code>Earliest Deadline First, EDF</code> 的抢占模式</strong>能够使得所有任务都能在 deadline 之前执行完成。</p>
<h6 id="有开始限期的非周期性实时任务"><a href="#有开始限期的非周期性实时任务" class="headerlink" title="有开始限期的非周期性实时任务"></a>有开始限期的非周期性实时任务</h6><ul>
<li>此类任务是非周期性的，不可预测的，若采用 <a href="#有完成限期的周期性实时任务">EDF 算法</a>，存在危险性</li>
<li>若在任务就绪前，预先知道任务的<strong>开始截止时间</strong>，则可以采用<strong>允许CPU空闲的EDF调度算法 <code>Earliest Deadline with Unforced Idle Times</code></strong></li>
<li>优先调度截止时间最早的<strong>合格任务</strong>，并让该任务运行完毕<ul>
<li>合格任务可以是还未就绪，但是事先知道其开始截止时间的任务</li>
</ul>
</li>
<li>尽管 CPU 的利用率不高，但这种调度算法可以保证系统中的任务都能按要求完成</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/0f09c62734fb10c414a49e7a627ad61f363a2bd9f092ea0b55fd8ec14f3e5954.png" alt="五个实时任务的执行信息" title>
                </div>
                <div class="image-caption">五个实时任务的执行信息</div>
            </figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/aae5f0d87da23e977e16bd4f5bedb7e92a44258d8c57d8eb57f1719d1e013c0f.png" alt="不同执行策略和效果" title>
                </div>
                <div class="image-caption">不同执行策略和效果</div>
            </figure>

<p>允许 CPU 空闲、优先调度 deadline 最早的（可能还未就绪的）合格任务，使得其能完成 B 任务。</p>
<h6 id="速率单调调度算法"><a href="#速率单调调度算法" class="headerlink" title="速率单调调度算法"></a>速率单调调度算法</h6><ul>
<li><code>Rate Monotonic Scheduling, RMS</code></li>
<li>周期性任务</li>
<li><strong>任务速率</strong>：任务周期（单位：秒）的倒数，以赫兹为单位</li>
<li>任务速率用于优先级的确定<ul>
<li>任务周期越短，优先级越高</li>
<li>优先级函数是任务速度的单调递增的函数</li>
</ul>
</li>
<li>系统按任务优先级的高低进行调度</li>
</ul>
<h5 id="实时系统处理能力限制"><a href="#实时系统处理能力限制" class="headerlink" title="实时系统处理能力限制"></a>实时系统处理能力限制</h5><p>假定系统中有 $m$ 个周期性的硬实时任务，任务 $i$ 的处理时间为 $C_i$，周期为 $P_i$，则在单处理机情况下，必须满足下面的限制条件： </p>
<p>$$\sum_{i=1}^m \frac{C_i}{P_i} \leq 1$$</p>
<p>即系统中各个任务的处理器利用率总和不能超过 1（CPU的利用率 = 任务执行时间 / 任务周期）。</p>
<h5 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h5><blockquote>
<p>高优先级任务被低优先级任务阻塞，导致高优先级任务迟迟得不到调度。但其他中等优先级的任务却能抢到CPU资源。– 从现象上来看，好像是中优先级的任务比高优先级任务具有更高的优先权。——<a href="https://www.jianshu.com/p/c1f7aa944dda" target="_blank" rel="noopener">信号量优先级反转（翻转）与优先级继承– kummer话你知- 简书</a></p>
</blockquote>
<ul>
<li>可能发生于任何基于优先级的可抢占的调度方案中</li>
<li>已在火星探路者中发生</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/6ee2f2f43447dae9c57d0dc6df355bec0fc549695c1ee4a57240abbaa1f8d346.png" alt="例子" title>
                </div>
                <div class="image-caption">例子</div>
            </figure>  

<p><img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/d95d46d4d66424e32e1c26e3fb74aa0cc5dc56548ea763618fea476cdc709456.png" alt="解决方案"></p>
<h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><h4 id="并发的原理"><a href="#并发的原理" class="headerlink" title="并发的原理"></a>并发的原理</h4><p>日常生活现象：</p>
<ul>
<li>过十字路口</li>
<li>理发店理发</li>
<li>银行取钱</li>
<li>足球比赛</li>
</ul>
<p>为什么需要“规则和秩序”？</p>
<ul>
<li>个体自主性:     异步（车辆，行人，顾客）</li>
<li>资源稀缺性:     独占（十字路口，理发师，ATM）</li>
<li>任务需合作:     协作（进球）</li>
</ul>
<p>多道程序设计为什么需要同步？</p>
<ul>
<li><strong>进程</strong>是计算机中的独立个体，且具有异步性、并发性</li>
<li><strong>资源</strong>是计算机中的稀缺个体，需共享，如CPU、内存、I/O设备</li>
<li>进程之间可能需要<strong>协作</strong>完成任务</li>
</ul>
<h5 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h5><ul>
<li><strong>原子操作</strong>：由一个或多个指令序列实现的动作或函数，对外不可见，一组指令要么都执行，要么都不执行。（数据库并发中的事务也有原子性）</li>
<li><strong>临界资源</strong>：不可同时访问，必须互斥访问的资源，如打印机</li>
<li><strong>临界区</strong>：访问<strong>临界资源</strong>的代码，任意时刻只能由一个进程在这段代码中运行</li>
<li><strong>互斥</strong>：当一个进程在<strong>临界区</strong>访问共享资源时，其他进程不能进入该<strong>临界区</strong>访问共享资源的情形</li>
<li><strong>忙等现象</strong>：当一个进程等待进入<strong>临界区</strong>时，它会继续消耗处理器的时间</li>
<li><strong>活锁</strong>：两个或两个以上的进程为响应其他进程而持续改变自己状态，但是不做有用工作的情形</li>
<li><strong>死锁</strong>：两个或两个以上的进程因等待其他进程做完某些事而不能继续执行的情形</li>
<li><strong>竞争条件</strong>：多个进程或线程读写共享的数据时，结果取决于多个进程的指令执行顺序</li>
<li><strong>饥饿</strong>：一个具备执行条件的进程，被调度程序无限期的忽视而不能调度的情形</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/d9393439dc3d0ca24039b39a80f0e3561ad8e1e89c5ec9cbe4147c40e9b8fc3e.gif" alt="忙等、饥饿和死锁" title>
                </div>
                <div class="image-caption">忙等、饥饿和死锁</div>
            </figure>  

<h5 id="并发控制的产生"><a href="#并发控制的产生" class="headerlink" title="并发控制的产生"></a>并发控制的产生</h5><p>产生原因：</p>
<ul>
<li>单处理器的交替执行和多处理器的重叠执行<ul>
<li>可看作并发处理的示例</li>
<li>二者表达的是同样的问题——进程的相对执行速度不可预测，其取决于：<ul>
<li>其他进程的活动</li>
<li>操作系统处理中断的方式</li>
<li>操作系统的调度策略</li>
</ul>
</li>
</ul>
</li>
<li>进程执行的相对速度不可预测，给并发带来了困难<ul>
<li>资源共享充满了危险性</li>
<li>操作系统需要优化管理资源的分配</li>
<li>定位程序的设计错误很困难</li>
</ul>
</li>
</ul>
<p>如，两个进程共享 <code>echo()</code> （如下）可能会出现问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> chin;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  chin = getchar()</span><br><span class="line">  chout = chin;</span><br><span class="line">  <span class="built_in">putchar</span>(chout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://lyh543.coding.net/p/pic-bed/d/pic-bed/git/raw/master/52496acccf6f98f76ff991478a120d1a6d454185437fe04df573452dc1836976.png" alt="两端并行的 echo()" title>
                </div>
                <div class="image-caption">两端并行的 echo()</div>
            </figure>  

<p>如图，P1 程序输入 x，但输出 y。</p>
<p>解决方法：</p>
<ul>
<li>控制对共享资源的访问</li>
<li>使得一个进程的功能和输出结果与执行速度无关</li>
</ul>
<p>于是，我们从进程的交互方式入手，不同的交互方式，并发控制问题不一样。</p>
<h5 id="进程间的交互方式"><a href="#进程间的交互方式" class="headerlink" title="进程间的交互方式"></a>进程间的交互方式</h5><p>进程间的关系：</p>
<ul>
<li>竞争</li>
<li>通过共享合作</li>
<li>通过通信合作</li>
</ul>
<h6 id="进程间的竞争资源"><a href="#进程间的竞争资源" class="headerlink" title="进程间的竞争资源"></a>进程间的竞争资源</h6><ul>
<li>进程间不知道彼此的存在</li>
<li>进程竞争使用同一资源时，它们之间会发生冲突</li>
<li>这类资源如：I/O设备、存储器、处理器、时钟</li>
</ul>
<p>进程竞争资源时，并发控制面临三个问题：<strong>互斥、死锁、饥饿</strong></p>
<h6 id="进程间通过共享合作"><a href="#进程间通过共享合作" class="headerlink" title="进程间通过共享合作"></a>进程间通过共享合作</h6><ul>
<li>多个进程可能共享一个变量、共享文件或数据库</li>
<li>一个进程的结果可能取决于从另一个进程获得的信息</li>
<li>进程知道其他进程也可能共享同一个数据，因此必须合作</li>
</ul>
<p>进程通过共享合作时，并发控制面临四个问题：<strong>互斥、死锁、饥饿、数据一致性</strong>（比上面多一个数据一致性）</p>
<h6 id="进程间通过通信合作"><a href="#进程间通过通信合作" class="headerlink" title="进程间通过通信合作"></a>进程间通过通信合作</h6><ul>
<li>进程间通过通信完成同步和协调彼此活动</li>
<li>一个进程的结果可能取决于从另一个进程获得的信息</li>
<li>通信可由各种类型的消息组成，发送或接收消息的原语由操作系统或程序设计语言提供</li>
<li>不涉及对共享资源的访问</li>
</ul>
<p>进程通过通信合作时，并发控制面临两个问题：<strong>死锁、饥饿</strong></p>
<h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><p>互斥的要求（访问临界区的原则）：</p>
<ul>
<li>空闲让进：如临界区空闲，则有进程申请就立即进入</li>
<li>忙则等待：每次只允许一个进程处于临界区（互斥）</li>
<li>有限等待：保证进程在有限时间内能进入临界区(不会死锁或饥饿)</li>
<li>让权等待：进程在临界区不能长时间阻塞等待某事件</li>
</ul>
<h5 id="互斥：软件方法"><a href="#互斥：软件方法" class="headerlink" title="互斥：软件方法"></a>互斥：软件方法</h5><ul>
<li>通过在进入区设置和检查一些<strong>标志</strong>来判断是否有进程在临界区</li>
<li>若已有进程在临界区，则在进入区通过循环检查进行等待</li>
<li>进程离开临界区后在退出区修改标志</li>
</ul>
<h6 id="初步设想——轮换使用临界区"><a href="#初步设想——轮换使用临界区" class="headerlink" title="初步设想——轮换使用临界区"></a>初步设想——轮换使用临界区</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享的全局变量</span></span><br><span class="line"><span class="keyword">int</span> turn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程 P0 的代码</span></span><br><span class="line">P0()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (turn != <span class="number">0</span>);    <span class="comment">//进入区</span></span><br><span class="line">    <span class="comment">// 进程P0的临界区代码;  //临界区</span></span><br><span class="line">    turn = <span class="number">1</span>;             <span class="comment">//退出区</span></span><br><span class="line">    <span class="comment">// 进程P0的其它代码    //剩余区</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进程 P1 的代码</span></span><br><span class="line">P1 ()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (turn != <span class="number">1</span>);    <span class="comment">//进入区</span></span><br><span class="line">    <span class="comment">// 进程P1的临界区代码;  //临界区</span></span><br><span class="line">    turn = <span class="number">0</span>;             <span class="comment">//退出区</span></span><br><span class="line">    <span class="comment">// 进程P1的其它代码    //剩余区</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>评价：</p>
<ul>
<li>严格轮换，实现了<strong>互斥</strong>访问</li>
<li>在临界区外失败也会影响其他进程的执行</li>
<li><strong>忙等</strong></li>
<li><strong>违反了“空闲让进”</strong>原则</li>
</ul>
<h6 id="第一次改进——设置临界区状态标志"><a href="#第一次改进——设置临界区状态标志" class="headerlink" title="第一次改进——设置临界区状态标志"></a>第一次改进——设置临界区状态标志</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享的全局变量,标志临界区是否可用</span></span><br><span class="line"><span class="keyword">bool</span> flag[<span class="number">2</span>] = &#123;<span class="literal">false</span>, <span class="literal">false</span>&#125;;       </span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程 P0 的代码</span></span><br><span class="line">P0()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (flag[<span class="number">1</span>]);      <span class="comment">//进入区</span></span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 进程P0的临界区代码;  //临界区</span></span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">false</span>;      <span class="comment">//退出区</span></span><br><span class="line">    <span class="comment">// 进程P0的其它代码    //剩余区</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进程 P1 的代码</span></span><br><span class="line">P1 ()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (flag[<span class="number">0</span>]);      <span class="comment">//进入区</span></span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 进程P1的临界区代码;  //临界区</span></span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">false</span>;      <span class="comment">//退出区</span></span><br><span class="line">    <span class="comment">// 进程P1的其它代码    //剩余区</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>评价：</p>
<ul>
<li>忙等</li>
<li><strong>违反了“忙则等待”</strong>原则，互斥访问未实现（如果两段代码同时执行）</li>
</ul>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p><a href="#信号量">信号量</a>、<a href="#管程">管程</a> 都是提供互斥的方案。</p>
<h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者/消费者问题"></a>生产者/消费者问题</h4><h5 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h5><p><code>P()</code> 等价于 <code>wait()</code>，<code>V()</code> 等价于 <code>signal()</code>。</p>
<h5 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h5><p>两个生产者可以同时访问盘子</p>
<h5 id="示例四"><a href="#示例四" class="headerlink" title="示例四"></a>示例四</h5><p>推荐录 1 和 4。对于示例 4，能讲清楚为什么这是生产/消费者问题，而不是读写者问题。</p>
<h4 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者/写者问题"></a>读者/写者问题</h4><p>问题描述：</p>
<blockquote>
<p>多个进程访问一个共享数据区（可为文件、内存空间、寄存器）<br>其中若干读进程只能读数据，若干写进程只能写数据。<br>为数据库、文件、内存区及一组寄存器等的数据访问问题建立了一个通用模型。<br>示例——联网售票系统、12306<br>在该系统中，数据的查询和更新非常频繁，不可避免会出现多个进程试图查询或修改（读/写）其中某一条数据的情形。</p>
</blockquote>
<ul>
<li>问题的三种角色：<ul>
<li>读进程</li>
<li>写进程</li>
<li>共享数据</li>
</ul>
</li>
<li>问题的三个条件： <ul>
<li>同时读</li>
<li>同时写</li>
<li>互斥读写</li>
</ul>
</li>
</ul>
<p>读者/写者问题和生产者/消费者问题的区别：</p>
<ol>
<li>读/写者的数据可多次读，生产/消费者的数据消费完后就没有了</li>
<li>读/写者无需互斥，生产/消费者需要互斥</li>
</ol>
<h5 id="读者优先"><a href="#读者优先" class="headerlink" title="读者优先"></a>读者优先</h5><h5 id="公平优先"><a href="#公平优先" class="headerlink" title="公平优先"></a>公平优先</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readcount=<span class="number">0</span>, semaphore x=l, wrsem=<span class="number">1</span>, wsem=l;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    P(wrsem);</span><br><span class="line">    P(x);</span><br><span class="line">      readercount++;</span><br><span class="line">      <span class="keyword">if</span> (readercount == <span class="number">1</span>)</span><br><span class="line">        P(wsem);</span><br><span class="line">    V(x);</span><br><span class="line">    V(wrsem);     <span class="comment">// 这句不能放在 P(wrsem) 之后，否则如果下一个是 W，该 W 可能抢先该 R 操作进行 P(wsem)</span></span><br><span class="line">      READ;</span><br><span class="line">    P(x);</span><br><span class="line">      readercount--;</span><br><span class="line">      <span class="keyword">if</span> (readercount == <span class="number">0</span>)</span><br><span class="line">        V(wsem);</span><br><span class="line">    V(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    P(wrsem);</span><br><span class="line">    P(wsem);</span><br><span class="line">      WRITE;</span><br><span class="line">    V(wsem);</span><br><span class="line">    V(wrsem);      <span class="comment">// 这句不能放在 WRITE 之前吗？</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一道防线：<code>wrsem</code>，W、R均要排队，保证公平</li>
<li>第二道防线：<code>wsem</code>（拦所有 W 和第一个 R）</li>
<li>系统应该保证，一、二道防线之间只有一个 R 或一个 W</li>
<li>当某 R 进入第二道防线后，会把第一道防线打开</li>
<li>当某 W 进入第二道防线后，不会打开第一道防线；只有当 W 走的时候才会打开两道防线</li>
</ul>
<h5 id="写者优先"><a href="#写者优先" class="headerlink" title="写者优先"></a>写者优先</h5><ul>
<li>第一道防线：<code>rsem</code>，拦所有 R 和第一个 W</li>
<li>第二道防线：<code>wsem</code>，拦</li>
</ul>
<h5 id="写者优先改进"><a href="#写者优先改进" class="headerlink" title="写者优先改进"></a>写者优先改进</h5><p>避免了长队列（长队列是什么？？？）</p>
<h5 id="示例一-1"><a href="#示例一-1" class="headerlink" title="示例一"></a>示例一</h5><h5 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h5><p>读者优先 + 谁先上谁就是读者，妙啊。</p>
<h4 id="理发师睡觉问题"><a href="#理发师睡觉问题" class="headerlink" title="理发师睡觉问题"></a>理发师睡觉问题</h4><p>就是注意各种状态的信号量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n_customer= <span class="number">0</span>;     <span class="comment">//店里的顾客,含正在理发的人数</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;   <span class="comment">//waiting的互斥信号量</span></span><br><span class="line">semaphore bchair = <span class="number">1</span>;  <span class="comment">//理发椅的个数</span></span><br><span class="line">semaphore wchair = <span class="number">5</span>;  <span class="comment">//空椅子的个数</span></span><br><span class="line">semaphore ready = <span class="number">0</span>;   <span class="comment">//是否有顾客准备好</span></span><br><span class="line">semaphore finish = <span class="number">0</span>;  <span class="comment">//理发师是否完成理发</span></span><br><span class="line"></span><br><span class="line">main() &#123; <span class="function">cobegin <span class="title">baber</span><span class="params">()</span></span>; customer(); coend &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">baber</span><span class="params">()</span>               <span class="comment">//理发师进程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(ready);            <span class="comment">//有顾客准备好了</span></span><br><span class="line">        <span class="comment">// 理发</span></span><br><span class="line">        V(finish);            <span class="comment">//允许其他顾客理发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">customer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P(mutex);  <span class="comment">//互斥waiting变量的操作</span></span><br><span class="line">    <span class="keyword">if</span> (n_customer &lt; <span class="number">6</span>) <span class="comment">//店里顾客数没达上限</span></span><br><span class="line">    &#123;</span><br><span class="line">        n_customer++;   <span class="comment">//店里顾客数增1</span></span><br><span class="line">        V(mutex);  <span class="comment">//允许waiting变量的操作</span></span><br><span class="line">     	P(wchair); <span class="comment">//找一个空椅子坐下</span></span><br><span class="line">     	P(bchair); <span class="comment">//再找理发椅坐下</span></span><br><span class="line">    	V(wchair); <span class="comment">//释放一个空椅子</span></span><br><span class="line">     	V(ready);   <span class="comment">//该顾客准备好了</span></span><br><span class="line">     	P(finish);   <span class="comment">//等待理发师完成理发</span></span><br><span class="line">     	V(bchair); <span class="comment">//离开理发椅</span></span><br><span class="line">     	P(mutex);  <span class="comment">//互斥waiting变量的操作</span></span><br><span class="line">    	n_customer--;  <span class="comment">//等待顾客数减1</span></span><br><span class="line">     	V(mutex); <span class="comment">//允许waiting变量的操作  </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 离开;</span></span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><p><a href="#信号量">信号量</a>、<a href="#管程">管程</a> 都是提供互斥的方案。</p>
<p>管程 <code>monitor</code></p>
<ul>
<li>互斥：<strong>任意时候只能有一个进程进入管程</strong></li>
<li>同步：使用条件变量 <code>csignal()</code> 和 <code>cwait()</code></li>
</ul>
<h3 id="进程死锁"><a href="#进程死锁" class="headerlink" title="进程死锁"></a>进程死锁</h3><h2 id="内存管理-1"><a href="#内存管理-1" class="headerlink" title="内存管理"></a>内存管理</h2><h2 id="I-O-管理与磁盘调度"><a href="#I-O-管理与磁盘调度" class="headerlink" title="I/O 管理与磁盘调度"></a>I/O 管理与磁盘调度</h2><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2>
        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2020-10-27T16:11:05.546Z" itemprop="dateUpdated">2020-10-27 16:11:05</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="https://blog.lyh543.cn">
            <img src="/img/avatar.png" alt="lyh543">
            lyh543
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/操作系统/">操作系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算机科学/">计算机科学</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/课程笔记/">课程笔记</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://blog.lyh543.cn/computer-science/operating-system-classnote/&title=《操作系统 课程笔记》 — 小灰灰灰灰的博客&pic=https://blog.lyh543.cn/img/avatar.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://blog.lyh543.cn/computer-science/operating-system-classnote/&title=《操作系统 课程笔记》 — 小灰灰灰灰的博客&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://blog.lyh543.cn/computer-science/operating-system-classnote/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《操作系统 课程笔记》 — 小灰灰灰灰的博客&url=https://blog.lyh543.cn/computer-science/operating-system-classnote/&via=https://blog.lyh543.cn" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://blog.lyh543.cn/computer-science/operating-system-classnote/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/computer-science/assembly-language-and-interface-technology-of-microcomputer-classnote/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">汇编语言与微机接口技术 课程笔记</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/others/something-about-uestc/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">电子科技大学四年游记</h4>
      </a>
    </div>
  
</nav>



    

















<section class="comments" id="comments">
    <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>
        var id = location.pathname
        if (location.pathname.length > 50) {
          id = location.pathname.replace(/\/\d+\/\d+\/\d+\//, '').replace('/', '').substring(0, 50)
        }
        const gitalk = new Gitalk({
          clientID: 'ec7daa4e047c3c30570d',
          clientSecret: '025a9e40a1d101f28fd1a945d286a819e9fa1c3d',
          repo: 'lyh543.github.io',
          owner: 'lyh543',
          admin: ['lyh543'],
          id: id,      // Ensure uniqueness and length less than 50
          title: document.title.split('|')[0],
          distractionFreeMode: false  // Facebook-like distraction free mode
        })

        gitalk.render('gitalk-container')
    </script>
</section>




</article>



</div>

        <footer class="footer">
    <div class="top">
        

        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>lyh543 &copy; 2019 - 2020</span>
            <span>
                
                <a href="http://www.miitbeian.gov.cn/" target="_blank">蜀ICP备19034464号</a><br>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://blog.lyh543.cn/computer-science/operating-system-classnote/&title=《操作系统 课程笔记》 — 小灰灰灰灰的博客&pic=https://blog.lyh543.cn/img/avatar.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://blog.lyh543.cn/computer-science/operating-system-classnote/&title=《操作系统 课程笔记》 — 小灰灰灰灰的博客&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://blog.lyh543.cn/computer-science/operating-system-classnote/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《操作系统 课程笔记》 — 小灰灰灰灰的博客&url=https://blog.lyh543.cn/computer-science/operating-system-classnote/&via=https://blog.lyh543.cn" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://blog.lyh543.cn/computer-science/operating-system-classnote/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACoklEQVR42u3aQY7bQAwEQP//0841QGC5m5wJfCidjLVXYumgoXr4esXH+6/j+e//fk6+bc98+MDDw8NblP7pkkmhzzciKT0B5zXj4eHh3eZ9KuL5c/775LH+Do68Bjw8PLzf5OWXny0ebXuNh4eH98u8Z0DCmN0UPDw8vN/h5S1sHqfOIoz8dh/OWvDw8PBiXl7o73y+sr+Hh4eHt95VbyPU5PyboYG6Wjw8PLwLvLzc/UBAHSLErfaXOvHw8PCO8vIgNR+QygtNFoZZsIuHh4d3j3cqcj01LJXHuO2ihYeHh3eKtxm3Sh76ybct70AMgYeHh3eNlxSRBBDtwpMPbH0JU/Dw8PAu8PLLJCdqI9dZW58393h4eHg3eO1r/yyWPbvYFDXj4eHhXeZtRp3aZn0zoFBEIXh4eHgXeJsNsOeikxt3ClzkLnh4eHiHeG2zO+taZ5g8nvh4FTw8PLyjvPZxv48t2mVjNdaAh4eHd4GX/EPbas/i13YRKjbe8PDw8K7x8tf+WZjbLgZ7Kh4eHt49XlJWO4yVl77pgWfRMB4eHt6G116mjRWGuXJ85i9LBR4eHt4FXj5c1V5yFlK07AiPh4eHd5SXP6ZnDe5mc2vT0OPh4eHd4519cLcR8L1498tMGR4eHt4h3qs8kgu0LXi7OBVvDHh4eHgXeLN2uV0wWuQ+XMbDw8P7n7zZ+NTsFpxdruo1Bw8PDy/mvcsj+a/8EZ8HFsNv8fDw8C7wNheebZ5twotZfIyHh4d3g7cvOr+Lm9/UW194eHh4l3l56W3beqP5Lm4xHh4e3s/wZpv6s82tVW14eHh4P8DbJxz52fIQZNih4+Hh4S14s0GrTXzwvBjsR6/w8PDw7vFmL/zt2OgsgGhj5dd+pcLDw8N7Ov4APSR9gghThxkAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>








</body>
</html>
